---
title: "DataExpert.io - Week 1 Homework (FINAL RESULTS WOO) - Data Engineering Bootcamp"
author:
  - "Jade Codes"
published: 2024-11-26
source: "https://www.youtube.com/watch?v=aT5Ntv-ogqA&t=3436s"
image: "https://i.ytimg.com/vi/aT5Ntv-ogqA/maxresdefault.jpg?sqp=-oaymwEmCIAKENAF8quKqQMa8AEB-AH-CYAC0AWKAgwIABABGC4gZyhyMA8=&rs=AOn4CLAuHTep0wp06VSbvPDSkrzIKKeieg"
created: 2025-03-23
tags:
  - "youtube"
  - "Data_Engineering"
  - "SQL_Bootcamp"
  - "Data_Modeling"
summary: "A walkthrough of a Data Engineering Bootcamp homework, covering SQL queries, data modeling, and incremental backfills. Learn from a real-world example!"
---
# DataExpert.io - Week 1 Homework (FINAL RESULTS WOO) - Data Engineering Bootcamp

![DataExpert.io - Week 1 Homework (FINAL RESULTS WOO) - Data Engineering Bootcamp](https://www.youtube.com/embed/aT5Ntv-ogqA&t=3436s)

> [!summary]- Description
> Thank you for joining me on my Data Engineering Bootcamp journey!
> 
> I'm so excited to have you here as we work through this incredible free bootcamp together. A huge shoutout to Zach for creating such an amazing resource!  
> 
> Before we dive in, let’s go over a few quick house rules:  
> 1️⃣ If you’re also following along with the bootcamp, make sure you check out the official site at:
> https://bootcamp.techcreator.io/ 
> 2️⃣ Don’t forget to watch Zach's videos directly too! He deserves the watch hours, and you deserve the credit for completing the bootcamp.  
> 
> This bootcamp is completely free, but I also want to let you know I’ll be joining Zach's paid bootcamp in January. 
> 
> If you're interested in leveling up your skills even further, you can use my link for 20% off: 
> https://www.dataexpert.io/jade
> 
> Thank you again for being here, let’s make the most of this bootcamp and learn some amazing skills together!

> [!note]- Transcript (Youtube)
> for that hey everyone sorry I'm just sharing the link for the this hi everyone so welcome back to um to my PG admin and and over the weekend I was can everyone hear me fine by the way I hope everyone can hear me fine but over the weekend I had a bit of an epiphany of how to do this and how to make it actually work in the way that I was meant to make it work and so we're going to do that today so one of the things that I realized that I was doing was that I was trying to be clever and input years like all together so from 2010 to 2012 where was actually like the homework only said that we needed to do it year by year by year so the so I just so so what that meant was that what I was trying to do was I was trying to aggregate like everything and then after I'd aggregated everything I then calculated the ratings further on whereas actually I could simplify this a whole lot so this might seem a bit unorthodox and people might cry a little bit but I I deleted the entire thing and started again um so I just recreated the table for actors and I also decided that because I could do the aggregation before I didn't actually need this year here um so in the if we go back to the GitHub uh GitHub we go to the instructions for the homework you'll see here that in the films I there wasn't any mention of actually needing the year in there so I removed that completely again and so I'm just going to run these commands again to drop this and \[Music\] create and then I'm going to C that again I'm not recreating this because this was fine I'm going to recreate the actess table recreate and then start again fresh on the cumulated table so the first thing that I needed to do was get the last year's results from the actress table so with last year as and then select star from uh actors where and then current year equals equals and we're just going to say last year was 200 and just a 2,000 for now and then from that I then did uh with with this year as from actors \[Music\] films where year equals 2001 and then from that I then did an aggregation so I wanted to get the ratings initially so I did this with so I just did select actor ID well actually I did actor first and then I realized actually like you could have after doing some um different testing so on different years so I tested from 2001 to 2010 and in 2005 to 2006 there was an actor actress with the exact same name as each other but they had different actor IDs so I changed my query to be actor ID rather than actor and then I also did average rating um which was this this thing here and then um we do the from this year and then we also do a group by Act and so even just by doing this uh you don't need the with the even just by doing this I'm I'm misspelling stuff now that gives you the the the average rating for that year which was something that was quite difficult like in the other way of doing it but it was really really simple to do it this way so I then change this to be ratings as here and then I did the next select which was select and then we started coalescing so um I can't spell the word coess I'm really bad at that um I'm just going to do uh join um so another thing that I did uh was when I got to this point I joined this year as um this year how to join um last year as L and I'm just going to do that now to show you what what actually happened when I did this so I did last year do um C act ID this year ID and as someone who hasn't commonly used like poist directly um one of the things that uh I didn't actually realize was to you it's better to use KES rather than um distinct because Coles is used when maybe one value is null but the other one isn't or if they're the same then it joins them together but if one's null and the other one isn't then it'll use the value that's not null so you in in this scenario using cols is the right option and this is where like it gets a little bit interesting cuz let me just refresh this you but you can already see like um Ean just by doing this this query is way shorter than it was at the beginning so it's it's a lot a lot cleaner in my opinion doing it this way so that so then um I ended up you initially I ended up doing this this statement here so I did case and then um if when um tii dot films is null then um do I got films when then no it's not that it's um I um row uh and then and it was what is it the film struck is of that type and then you got Ty do um film tii do what's the other one I want I'm just going to write this really quickly but I'm going to show you why this isn't going to work like this isn't the right approach in a minute film ID else and then you can do um like a li films and then R is this reads to me like an R statement but it's not it's a conate so it concatenates um well it Aggregates the films from like the two arrows together basically so which is very confusing but that's what it does there someone who um and and then this is uh films definitely films and then yeah okay I'm just putting there and then and then um I then did an outer join on the rating ratings as are and then I did a case on this so I said if the rating is exists then use that if not use the previous rating so when our do rating is null then \[Music\] anything else I do raing and uh and then that is the uh quality class it's actually quality class and then um similarly you can do like an is active so is active so case when um Ty dot Ty is it Ty Y is null um Ty do is active is null then ly do is active actually I don't think I don't think the V is active on this thing I think it's just if l y is n t y is active is null then l y is active l um UI do then no then then false else true and as is active and that was all I did so that is pretty much all I did um initially and then let me make sure that that runs correctly I've not got anything else there have I to I do film have I got the AR have I got the um way of specifying an hour okay it's just because this is meant to be a um thing like that rather than in Cur races still figuring out the syntax but and I do not need do I not need the um as films okay I don't need the film so cool okay yeah and then that was on act on l. actor ID equals ty. actor ID and then on here it was on Ty actor ID equals R do actor ID and these are full out of join not just outter join you can see that I'm still getting to groups with the syntax here but that is pretty much what it is yeah when fill is now I'm going to call this average rating as well just because I think that makes it a little bit more explicit on what that is but um that is what this is going for and then okay yeah so so because this average rating here is um not actually the the quality class we need to cast it to the Quality class so this is then case uh when r dot average rating is greater than eight Then star when r. average rating is greater than seven then C spell star then good when R do average rating is greater than six then uh what's the next one average \[Music\] average rating no the last one is just else bad and then we end and that is a quality class as well so that's what I did um and I also added a group by um actor ID at the end just so I could test this gr by the I don't want to do that um uh no I didn't actually do that here I remember now I did I searched on so as you can see here like when this returns back it had four options for Charlton this this isn't what I wanted I wanted to have an aggregate of of of results so what I realized quickly is actually what I could do is rather than like doing two out of joins here I only needed the one so I could remove the um I could remove the reference to this year and just use ratings directly but what I could do in ratings is I would I could create an um aggregate of the films as well so what I did here in here was I then changed this to film and ratings and then in here I then did an array aggregate um of like the films for that year so I then did uh AR aggregate of the of the of the um the films for that year rather than like doing it later on here because then I could just do it in one place so I did row row and then I'm just going to copy um this bit here cuz that's pretty much the same thing that I \[Music\] did and then um I just call that as as current films so that like that we would know what that is um and then same with that so we have act ID current films and average rating but we also need the actor if we're not going to be using this here we also need the actor ID the actor and we also need the year as well and then because of that you also need to do a group buy as well so you need to do actor and year um if you want to have those have those things in there so I did that and then in here I was able to remove this and then I was just able the first thing that I did was I replaced I removed this here and I changed this to film I'm going to change this film and ratings so I just called this this year film and ratings here instead of having the second um out to join and that just meant that I could then also um remove a lot of complexities there as well so in here um instead of having add average rating I now have Ty so and then um in here where we have the films we then do uh like I like check on whether or not like the the current year is null or not so you can do um so just say when when the curent you is not like when I can't speak right now and couldn't use no then um thiss year do current films which is what I had up there and then when Ty do year is null then ly do films yeah films else um you can then you you would do an aggregate of the two so l. films aggregate see current films line4 and that's just because I I copied this over earlier and I didn't make it short Ty so that's all I did and then I got this much smaller query than where I was that before and a lot more concise and it it it works for the the for every every year so you can see like if I like insert now this query into the database then it it inserts every year so I'll just do a couple of years I'm just seeing if anyone's talking Petr uh hi J I want to refresh my SQL skills do you think this course you're doing could be a good choice I found it really really helpful like I haven't touched SQL in a while and even just by doing it for a few days I'm like okay yep that's what you need to do for that that's what you need to do for that so so um I've personally found it quite useful but it's I'd say not necessarily tailored for larning SQL it's more like expected to know it a little bit I guess like I've had to like research what the commands that I needed to use where stuff insert into and then that's the CCT film and then if I do 2002 and 2001 2002 2003 2003 2004 2004 2005 2005 2006 and then we just do uh select from where current year equals 2006 it that just been a bit weird I'm just not such in Star and you can see here for example that the aggregation is worked correctly um the all of the movies that they've got have been added for them and if I select St from actors uh actor films where where equals gly you can see for you can kind of see that all those movies there were ones that only had in what were included in in the agregate so yeah and I submitted this as as it as this was so you can kind of see the thought process there of okay well I can make it better by aggregating the rating before and I can then like do two a joins and then I'm like actually no I don't need to do two out joins and then um then slowly condensing it until you get a nice a nice small query which I was very happy with so this is my query query um ining inter actors I've got last year um this year this year film and ratings in my this year film and ratings I then aggregate the RO the this year's films and row together um I get the average rating for this year as well and then I do a join from this to last year's one and then I determine whether or not the they they are active this year or not so so you you determine that by whether or not they've released a film this year and if they haven't released a film then they're not active um and yeah that is what I did um and I got an A so so this was just for number um number two of the homework and then once we got to number two we're then into number three which is uh creating a um let me make this this here so we want an actor's history \[Music\] um uh table to basically store the history of when a actor was either their ratings changed or their like is active State changed so rather than starving for every year you just just you you only create a r when they've changed from the previous year so one of the things I found really like frustrating about like just this lab in general is that is this concept of start date and end date because to me a start date is a date it's not a year it's a date so I kept putting in year instead of date and then I initially got like an a iress because I'd put start year instead of start date and then end year as an end date no end date yeah end year instead of end date um and then as soon as I changed them to end date I I um I got it correct and and got my a so um hi Zach so yeah on the creating the actor's history um table we basically if you look at if you did the labs it was very very similar to doing that rather than having a scoring class you had a ratings class instead so that was pretty much the biggest change that that I I noticed to be on there so other than that there wasn't anything else other and and the fact that you created an actor ID instead of um The Player's ID as well so those those are the the main things that I I did differently so that was just a create um table actors history CDE yeah so this is what really got me cuz I kept putting cuz this is cor and then it started and I like why and then the llm told me off for it so I was like that's fine I I'll remove it I'll change it back um I've not deleted that table yet so I'm just going to drop um table I'm just going to drink some of my drink I'm sorry if that that you could hear that I don't know I I get really bad ick when I hear people drink so so sorry so so that's pretty much the the table the table done so that was like number three done three um and then yeah that was pretty pretty straightforward that one and then we move on to number four which is the backfill query for the the the the table so this is like basically creating a query that's going to generate the entirety of the tables for the last however many changes over the last however many years so just say an actor has been active in 200000 in 2000 all the way up into 2005 you kind of get a start you get a start year and an end year a start date and an end date um for for those years so your start would be 2000 and then your end would be 2005 and then um like just say they were then inactive for another two years you would then have like from 2006 to 2008 that they were inactive um 2007 probably can't count um and then that's basically uh what you would be doing so um this is the the I very much watched the labs for this this was really really useful I found that the labs really really helped this um but they pretty much give you a really good starting point for how to get this done for the actual like homework so literally like for me like the labs for the second um the second exercises were were really really useful so so for me the first thing in that that Zach does in in the labs is that he basically builds the like is previous um so so what we're doing is we're getting the previous values of the um Quality class and whether the is active so um this is so that you can then do a comparison of that quality to class and it is active with the current year so in the previous one is saying okay with with previous as and then select and then we select our actor ID we select our current year we select our quality class we select our is active and as well as that we select the the previous values for those so so that we can get the like the comparison between the like the current the C so you can get the comparison between the current state and the previous state so the way that Z do that in the the labs is he does this thing called lag which basically if you do some sort of like um group buy or ordering or like any sort of like RAR you have a list of r it'll get the previous value that you've chosen um so I thought that was pretty cool uh and um and then you can do like a partition by the actor ID and order by which then allows you to get that previous quality class so one thing I am going to do is one thing that I think is really really useful when doing this is just doing the queries individually just so that we can see what they are and I'm just going to make this bigger as well if you've noticed as well that I tried to make my um little picture as small as I could because I've had a few people just say like you know I I've not been able to see the cod as well so um I've tried to make it as small as I can so that people can see better I hope that's actually like made a difference so um and then we literally just do the same for the is active and then we do uh from AES so we we're using the actors class to populate this where isal 2021 so as you can see like for each year it's basically giving you a comparison between like the previous year and now so you can see like um you've got like 200 um for 2003 you've got good and true um but like there wasn't any previous quality class so there's nothing there and then you've got like good and true again and then good and true and then you've got average and true and then good and true so that you can see here for example that these are different um and so what you want to be doing in the next query the indic when you start like comparing them is seeing okay well when are these different so this is the like just getting the differences and then you need to do that comparison to determine which ones are actually different and now we've got this with previous so this is the previous results and this is then okay well we need to indicate when these things change so when when something's changed we can then create an indicator that's going to say when something's changed so again I'm going to just do the select statement for this and then we're going to see what that returns before actually then um before then actually creating another CTE and so all we're doing here is we're doing a comparison of does this equal um or like not equal the um previous one H and then if NE then still one um else zero and because basically what we're saying is if if the quality class does not equal the previous quality class then it is true that it's changed when it's active does not equal previous is active then it's also true that something has changed however if neither of those have changed then we can say it's zero and it's not true so then we can then say that that's not um the case and in in sax thing he also calls this a change indicator so I just called it a change indicator as well and then from that we we are doing this from the previous query so this is from the with previous query so as you can see like um the change indicator is saying zero here this is just because this is an also like this like you only really are comparing it when there like if if it's the previous value was null then it was never like actually set so so you wouldn't say like it it's actually changed whereas like here for example this has changed cuz it's gone from good to average and then from this this one um here is gone from is active it's gone from not is is active to not is active so that's when you you start doing those comparisons of when they're actually like different to each other so similarly to what Zach did in his p i call this with indicators again I just thought like you know I'm not one of those people who like to like create differences just to try and be edgy I think if someone's given a good name to somebody then just leave it um and then again he he then wants to create a streak to figure out how long um how long it's been between like between one year to the other year so you're figuring out okay how long has this actor actually like um being active or how long has this actor like being uh um kept the same rating also like it' be great if if this has been actually useful like this is just just get on with elctric Jade I want to watch Elric show with you or if you just want to like do something different just let me know like and and I could just be talking complete like bull poopy right now but yeah I also um I don't know if anyone was watching sorry I've got like um I don't know if anyone knows but I'm getting I'm getting tested via ADHD and one of the things that happens is that I have like loads of woo things going wrong so um I don't know if anyone knows but on on Friday I um I played some copyright music on my on my YouTube I played Lincoln Park um because I finally got got some got it working I was very very happy um and then on Saturday YouTube basically kicked me out of everything like and it made out like I'd been doing suspicious activity on my account and so that wasn't good so I'm just cre I'm just identifying the the streaks now so I'm just writing again this is a very similar like um query to what what acted the B biggest difference was just partitioning it by actor I by actor ID instead of um instead of the player ID and then ordering by the current year and then so again let's run this query again uh I'm going to change so you can see here this this person just keeps changing a lot they don't know what they want to do so every time like every time there's a one we just like figure out like that's another like another another streak that's happened to them so every time like they they change something um we we know that that's a year that we need to basically figure out like what um what the difference is between that year and and and the the next year um so yeah that person can't make up their mind is there any ones that have uh o I'm sorry I'm just I'm just curious order by descending um as what should I call that I'm just trying to figure out like um that's what I'm just curious like if I order byy descending like what um is that the right way to do it what's the right way what is it is it fully descending is it a something am I just doing it am I just yeah cool okay so someone has ay AC ID and she could if iend I wanted to see like what like which person has the worst one but I don't think that's going to work um we have some that have like five so yeah they've got a lot of \[Music\] changes yeah they just changed every year right I don't need that but that's just something that's interesting um and then so so this is now you know all all the streaks that you need you need and basically then what you're going to do is once you like figure out what what your different streaks are you can then Group by by those streaks right um and from that we can then select build up our query basically I'm going to say 2024 cuz 2024 is a COR here um but honestly like don't you think this is confusing like start it couldn't you come on Zach so where's the um commas and so this I found it quite awkward to to like just debug this and make sure that it was right so I just did a I ended up doing an order by just to verify that it was in the order that I wanted it to be um so I also did a order buy and um start date just to verify that like it was doing it in the right order that I wanted to so you can then see like um we are then grouping by the the you can see that it's actually like been able to identify like the um actor ID the isactive the quality class the current you the start date and the end date and then like because I've ordered it by start date you can see that it goes up so like for ACT ID with um with this ID you can see that you know the the the they were true and good from 2003 to 2003 um they were um by miss something incredibly important I need to debug the end date there cuz that shouldn't have happened and all right okay that's because I put Mini Min Min year for both um I was wondering why why isn't it giving me the right answers there this is why it's important to debug things and make sure that you're getting the right answer um okay that looks a lot better now um so we've got uh 2003 to 2004 they were true and and good then they moved from True to average from 2005 and then um they in in 2006 they um were were um faults and average so you can see that they've changed those years and then for um 08 uh we've got true and average and then it changed to false to not being active uh and then let me find someone with a lot of changes yeah so this person changed from 2002 to two just they were true and good and then um false and good to to 2003 to 2005 and then they were true and good from 2006 to 2006 so that's all working as I'm correcting uh so I am currently using PG admin um for my setup so uh if you wanted \[Music\] to use the same thing I have like a little dock compos file here that uses PG admin um but it's on meub so if you want to use it feel free to take it um but okay that that's working as I anticipated and so then that insert you can just do an insert into um this table here you can see it inserted successfully which is fantastic uh and so that was the full back fill but then we also needed to figure out how to do um an incremental back fill so that was the next thing to do just going to finish drinking my drink do anyone found this actually useful by the way cuz I don't know if it I don't know if it I'm just talking into the void at this point wait sorry I'm just drinking and then I've literally let let my entire C go go cold so it's it's it's a sad day okay so the the first thing that sa did for his incremental career was that he created a like actor's SCD type so that we just was storing things like the quality class the is active the start date and the end date so that's the FAS thing that I'm going to do this is where like I got my um my my air minus from because I put start here not in this bit but in my select Okay so just going to make sure it create from the beginning again okay come one thing which is my worst like enemies is putting semicolons I always forget about them in this language all right just trying to set up my OBS ah you just you probably all see each other so the first thing we do is we get the last season um last season Scar from the like actor history table so we want to get the last season or well the last year cannot type today this is I know I keep saying it but this is where it kept tripping me up things like this so I'm just going to I'm not going to get anything from that no so if we even just say we do 2006 20 20 20 24 I put yeah we not going to get a lot that the difficulty is is that that in here yeah in here we're not going to get a lot of data that's fine about that later as well as that we want to get the historical data so we want to get so let me put this back to 2023 2023 is so if we just move this out of here for now or if we just do this one run this select you can see there's quite a few in here so that's all good then the next thing you need to do is get this year's data and this year's data is going to come from the actess table so one of the things that \[Music\] um so I'm going to sneeze no I'm not I'm okay I'm okay one of the things that we can do is this use data as select star from act where Curr year equals so what I'm going to do actually is I'm going to delete some of the data yeah um fils 2021 okay that's fine so I'm going to just change the data here where I do it an insert I'm going to do um drop drop delete and I'm just going to popy it the last five years \[Music\] 15 I think that's just for some reason going a bit weird that's fine okay I like that for now and then I'm just going to that out then I'm going to delete from I'm going to change that to 2,000 I'm going to just make sure any checking hello and then now we should be able to do our query for here if I do this where 20 yep and then historical data where 20 and then the end date is less than 20 20 20 we should have some data there and then this year is where it's 2021 so we should have some data here okay we need to populate this you now as well actually so change now to 20 in 2021 y let's put that in there and then we should now have some data in here Perfecto cool and then now we should be able to incrementally combine these two table together so we now need to verify which records are un changed so we then like basically do a search on where the last year and this year have um are the same but first of all let's just do a regular select uh and uh join so we want to do a join then we want to do last year as um a I were on this year. actor ID equals last year act ID where TS do quality class equals l. quality class and is active equals is active and then we also want to make sure we're selecting the other things so um Co I can't spell that word Co I do don't you think it looks wrong that word looks wrong to me I'm sorry but it does to be fa we we don't want to coess that we want to have start and then we want to have the current year as end dat I can't SP so you can now see like we get the last result of unchanged records so these things haven't changed so if these things haven't changed then these are all the results that haven't changed and then we also want to find the ones that have changed so these are um unchange records and then once we've done this we get our unchange records we get our change records so we want to do select just do the ACT ID again and then we want to do the like we need to get both rows so we need to get the rows from the previous and the rows from the current so we then can do an unest and this is where we start using the um the like actors SCD type here because we can then use that to create a um like two an array with two like values in to compare them just using that so I can use it as a reference and then so this is we're just you know getting the same row as as last year but we also need to get the current year but the current year doesn't have a start day and an end day it just has the current year so it's just going to be the current year for both of them so so it's going to be here it's going to be current year and same here and so we don't have to like we don't have to get the start date and end it because it's it is if if it's changed then the current year is going to is the start date is going to be the current year and then the end date is going to be the current year that's just how it's going to be and then the last the previous year is going to have the start date and the end day as the previous year that that's oh my God that's sounding like I was really like you know explaining that like I was yeah I don't think you're DB I promise and then from this we can then do from this you data and then we want to join last use data and then on the actor ID so we want to do make sure that we're always joining the ACT ID where the the the two don't equal so we want to make sure that we're only doing it when um Quality class does not equal um the quality class actually we only need to do a left join here I think I'm pretty sure because we're only getting change records here so a left join should chice cuz we only care about values that previously existed that have changed so a left join is absolutely fine bye that's fine and then that should be oh no it's an R it's not an and it's an R so we're basically saying um get us all the previous records that will join to our table that match on actor ID where quality class and is active do not equal me and those bloody semicolons those bloody commas I mean I am and then we've got this now we've got so we've got all these rows where we've got this but we need to we need to then split these things out so we then need to say okay well we're going to create unnested change records so this is um with um select and then we can then create change records we can we can then basically map all these things out oh my God my back is so now we're just basically making these their own columns and so you can see that they've all been split out now um and then the last thing to do like is just get any new records so any records that haven't had previous values um so this is now the unnested unnested change records as just seeing if anyone's messaged me no so now we can do a new record so select um ts. ID um \[Music\] from this year data um and then we can do a left join again on equals or act ID is null and then we can just select all the things we want and like this is where I got my a minus you know as men earlier I got an A minus because I put this as start year instead of end start dat like that's and then as soon as I corrected it to start start date then I got I got the like a but yeah don't be like me follow the rules even when the rules don't make sense if you want to get your grade so as you can see there's lots here that started in 2021 and so I am going to do a new record and then the last thing to do is to just to basically like um Union everything together so select star from and yeah that is pretty much the entire homework basically that's all I need to to do um I think for the last one I didn't need to insert them into the the table uh just because IDE you want to do merge but it was it just wasn't specified in the homework the query was just specified so I left it out there but um I could also add the current U as well but yeah that is pretty much everything that I did to get the the different values I'm just going to do order so you can see all the new values are there and that was everything really for the homeworks yeah um yeah I felt I felt like I really over complicated the first one I so if I just go to my data. oh if anyone wants to you can go to Jade as well to to join me if you want to join the um data engineering boot camp um I'm I'm going to be doing the the paid as well but uh if we go to the lessons and we go to the free boot camp uh it's not the lessons it's the assignments uh you can see I got an A here and it gives you some nice feedback it gives you like some details on what you could do um \[Music\] so you're using L and changing logic to track changes and quality cap the aggregation and summarization of data inter start dates are comprehens done ensure the queries comply with any performance requirements especially with large data sets and then the approach uses structured types effectively um consider setting up automated checks or logs to detect discrepancies during the transaction between years the SQL provide demonstrates a strong understanding of both basic and advanced SQL Concepts such as types window functions and sud management queries are complex yet well structured make sure to comment on complex logic to improve maintainability consider indexing frequently used columns to improve query performance such as actor ID and year and ensure that future queries formulations are remain remain scalable as the data set grows so I thought that was nice nice little um summary of the the file that I submitted so I was pretty happy with that and then that is the the homework \[Music\] um should I create a new live stream for the lab three or or the lecture three or should I continue on this one for I will start a new stream based on the lack of responses then post the um post that on link as well just say that I'm starting a new stream for lecture three um cool right I will see you on there I'm going to get a new drink and then start over uh it's been a long session I've done a lot of talking and hopefully the next session I won't be doing as much talking so that that's good uh so yeah I'll see you on that one bye


 > [!info]
> - **Simplify the Problem:** Break down complex tasks into smaller, manageable steps. The speaker initially tried to aggregate data for multiple years, then realized the homework only required year-by-year analysis (3:19).
> - **Leverage CTEs (Common Table Expressions):** Use CTEs to organize and simplify complex SQL queries. The speaker demonstrates how to use CTEs to break down the problem into smaller, logical steps (5:35).
> - **Choose the Right SQL Functions:** Understand the nuances of SQL functions like `COALESCE` vs. `DISTINCT`. `COALESCE` is better suited when handling null values and merging data (9:59).
> - **Aggregate Data Early:** Aggregate ratings before joining tables to reduce complexity and improve query performance (23:38).
> - **Debug Incrementally:** Test queries in smaller parts to check the output and identify errors. The speaker frequently runs `SELECT` statements to examine intermediate results (42:00).
> - **Verify Results:** Use `ORDER BY` clauses to verify that the data is sorted correctly and that the results match expectations (56:12).
> - **Pay Attention to Detail:** Even small errors, like using the wrong date field, can lead to incorrect results. Double-check all field names and data types (36:46, 58:51).
> - **Understand the Logic:** Focus on understanding the underlying logic of the problem rather than just copying code. The speaker explains the thought process behind each step (32:28).
> - **Reuse Proven Solutions:** Don't reinvent the wheel. If a solution works well, reuse it. The speaker reuses CTEs and query patterns from the labs (47:48).
> - **Incremental Backfills:** Create separate queries for full and incremental backfills. This allows you to efficiently update the table with new data (1:00:53).