/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/fuzzaldrin-plus/lib/scorer.js
var require_scorer = __commonJS({
  "node_modules/fuzzaldrin-plus/lib/scorer.js"(exports) {
    (function() {
      var AcronymResult, computeScore, emptyAcronymResult, isAcronymFullWord, isMatch, isSeparator, isWordEnd, isWordStart, miss_coeff, pos_bonus, scoreAcronyms, scoreCharacter, scoreConsecutives, scoreExact, scoreExactMatch, scorePattern, scorePosition, scoreSize, tau_size, wm;
      wm = 150;
      pos_bonus = 20;
      tau_size = 150;
      miss_coeff = 0.75;
      exports.score = function(string, query, options) {
        var allowErrors, preparedQuery, score, string_lw;
        preparedQuery = options.preparedQuery, allowErrors = options.allowErrors;
        if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {
          return 0;
        }
        string_lw = string.toLowerCase();
        score = computeScore(string, string_lw, preparedQuery);
        return Math.ceil(score);
      };
      exports.isMatch = isMatch = function(subject, query_lw, query_up) {
        var i, j, m, n, qj_lw, qj_up, si;
        m = subject.length;
        n = query_lw.length;
        if (!m || n > m) {
          return false;
        }
        i = -1;
        j = -1;
        while (++j < n) {
          qj_lw = query_lw.charCodeAt(j);
          qj_up = query_up.charCodeAt(j);
          while (++i < m) {
            si = subject.charCodeAt(i);
            if (si === qj_lw || si === qj_up) {
              break;
            }
          }
          if (i === m) {
            return false;
          }
        }
        return true;
      };
      exports.computeScore = computeScore = function(subject, subject_lw, preparedQuery) {
        var acro, acro_score, align, csc_diag, csc_row, csc_score, csc_should_rebuild, i, j, m, miss_budget, miss_left, n, pos, query, query_lw, record_miss, score, score_diag, score_row, score_up, si_lw, start, sz;
        query = preparedQuery.query;
        query_lw = preparedQuery.query_lw;
        m = subject.length;
        n = query.length;
        acro = scoreAcronyms(subject, subject_lw, query, query_lw);
        acro_score = acro.score;
        if (acro.count === n) {
          return scoreExact(n, m, acro_score, acro.pos);
        }
        pos = subject_lw.indexOf(query_lw);
        if (pos > -1) {
          return scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m);
        }
        score_row = new Array(n);
        csc_row = new Array(n);
        sz = scoreSize(n, m);
        miss_budget = Math.ceil(miss_coeff * n) + 5;
        miss_left = miss_budget;
        csc_should_rebuild = true;
        j = -1;
        while (++j < n) {
          score_row[j] = 0;
          csc_row[j] = 0;
        }
        i = -1;
        while (++i < m) {
          si_lw = subject_lw[i];
          if (!si_lw.charCodeAt(0) in preparedQuery.charCodes) {
            if (csc_should_rebuild) {
              j = -1;
              while (++j < n) {
                csc_row[j] = 0;
              }
              csc_should_rebuild = false;
            }
            continue;
          }
          score = 0;
          score_diag = 0;
          csc_diag = 0;
          record_miss = true;
          csc_should_rebuild = true;
          j = -1;
          while (++j < n) {
            score_up = score_row[j];
            if (score_up > score) {
              score = score_up;
            }
            csc_score = 0;
            if (query_lw[j] === si_lw) {
              start = isWordStart(i, subject, subject_lw);
              csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);
              align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);
              if (align > score) {
                score = align;
                miss_left = miss_budget;
              } else {
                if (record_miss && --miss_left <= 0) {
                  return Math.max(score, score_row[n - 1]) * sz;
                }
                record_miss = false;
              }
            }
            score_diag = score_up;
            csc_diag = csc_row[j];
            csc_row[j] = csc_score;
            score_row[j] = score;
          }
        }
        score = score_row[n - 1];
        return score * sz;
      };
      exports.isWordStart = isWordStart = function(pos, subject, subject_lw) {
        var curr_s, prev_s;
        if (pos === 0) {
          return true;
        }
        curr_s = subject[pos];
        prev_s = subject[pos - 1];
        return isSeparator(prev_s) || curr_s !== subject_lw[pos] && prev_s === subject_lw[pos - 1];
      };
      exports.isWordEnd = isWordEnd = function(pos, subject, subject_lw, len) {
        var curr_s, next_s;
        if (pos === len - 1) {
          return true;
        }
        curr_s = subject[pos];
        next_s = subject[pos + 1];
        return isSeparator(next_s) || curr_s === subject_lw[pos] && next_s !== subject_lw[pos + 1];
      };
      isSeparator = function(c) {
        return c === " " || c === "." || c === "-" || c === "_" || c === "/" || c === "\\";
      };
      scorePosition = function(pos) {
        var sc;
        if (pos < pos_bonus) {
          sc = pos_bonus - pos;
          return 100 + sc * sc;
        } else {
          return Math.max(100 + pos_bonus - pos, 0);
        }
      };
      exports.scoreSize = scoreSize = function(n, m) {
        return tau_size / (tau_size + Math.abs(m - n));
      };
      scoreExact = function(n, m, quality, pos) {
        return 2 * n * (wm * quality + scorePosition(pos)) * scoreSize(n, m);
      };
      exports.scorePattern = scorePattern = function(count, len, sameCase, start, end) {
        var bonus, sz;
        sz = count;
        bonus = 6;
        if (sameCase === count) {
          bonus += 2;
        }
        if (start) {
          bonus += 3;
        }
        if (end) {
          bonus += 1;
        }
        if (count === len) {
          if (start) {
            if (sameCase === len) {
              sz += 2;
            } else {
              sz += 1;
            }
          }
          if (end) {
            bonus += 1;
          }
        }
        return sameCase + sz * (sz + bonus);
      };
      exports.scoreCharacter = scoreCharacter = function(i, j, start, acro_score, csc_score) {
        var posBonus;
        posBonus = scorePosition(i);
        if (start) {
          return posBonus + wm * ((acro_score > csc_score ? acro_score : csc_score) + 10);
        }
        return posBonus + wm * csc_score;
      };
      exports.scoreConsecutives = scoreConsecutives = function(subject, subject_lw, query, query_lw, i, j, startOfWord) {
        var k, m, mi, n, nj, sameCase, sz;
        m = subject.length;
        n = query.length;
        mi = m - i;
        nj = n - j;
        k = mi < nj ? mi : nj;
        sameCase = 0;
        sz = 0;
        if (query[j] === subject[i]) {
          sameCase++;
        }
        while (++sz < k && query_lw[++j] === subject_lw[++i]) {
          if (query[j] === subject[i]) {
            sameCase++;
          }
        }
        if (sz < k) {
          i--;
        }
        if (sz === 1) {
          return 1 + 2 * sameCase;
        }
        return scorePattern(sz, n, sameCase, startOfWord, isWordEnd(i, subject, subject_lw, m));
      };
      exports.scoreExactMatch = scoreExactMatch = function(subject, subject_lw, query, query_lw, pos, n, m) {
        var end, i, pos2, sameCase, start;
        start = isWordStart(pos, subject, subject_lw);
        if (!start) {
          pos2 = subject_lw.indexOf(query_lw, pos + 1);
          if (pos2 > -1) {
            start = isWordStart(pos2, subject, subject_lw);
            if (start) {
              pos = pos2;
            }
          }
        }
        i = -1;
        sameCase = 0;
        while (++i < n) {
          if (query[pos + i] === subject[i]) {
            sameCase++;
          }
        }
        end = isWordEnd(pos + n - 1, subject, subject_lw, m);
        return scoreExact(n, m, scorePattern(n, n, sameCase, start, end), pos);
      };
      AcronymResult = function() {
        function AcronymResult2(score, pos, count) {
          this.score = score;
          this.pos = pos;
          this.count = count;
        }
        return AcronymResult2;
      }();
      emptyAcronymResult = new AcronymResult(0, 0.1, 0);
      exports.scoreAcronyms = scoreAcronyms = function(subject, subject_lw, query, query_lw) {
        var count, fullWord, i, j, m, n, qj_lw, sameCase, score, sepCount, sumPos;
        m = subject.length;
        n = query.length;
        if (!(m > 1 && n > 1)) {
          return emptyAcronymResult;
        }
        count = 0;
        sepCount = 0;
        sumPos = 0;
        sameCase = 0;
        i = -1;
        j = -1;
        while (++j < n) {
          qj_lw = query_lw[j];
          if (isSeparator(qj_lw)) {
            i = subject_lw.indexOf(qj_lw, i + 1);
            if (i > -1) {
              sepCount++;
              continue;
            } else {
              break;
            }
          }
          while (++i < m) {
            if (qj_lw === subject_lw[i] && isWordStart(i, subject, subject_lw)) {
              if (query[j] === subject[i]) {
                sameCase++;
              }
              sumPos += i;
              count++;
              break;
            }
          }
          if (i === m) {
            break;
          }
        }
        if (count < 2) {
          return emptyAcronymResult;
        }
        fullWord = count === n ? isAcronymFullWord(subject, subject_lw, query, count) : false;
        score = scorePattern(count, n, sameCase, true, fullWord);
        return new AcronymResult(score, sumPos / count, count + sepCount);
      };
      isAcronymFullWord = function(subject, subject_lw, query, nbAcronymInQuery) {
        var count, i, m, n;
        m = subject.length;
        n = query.length;
        count = 0;
        if (m > 12 * n) {
          return false;
        }
        i = -1;
        while (++i < m) {
          if (isWordStart(i, subject, subject_lw) && ++count > nbAcronymInQuery) {
            return false;
          }
        }
        return true;
      };
    }).call(exports);
  }
});

// node_modules/fuzzaldrin-plus/lib/pathScorer.js
var require_pathScorer = __commonJS({
  "node_modules/fuzzaldrin-plus/lib/pathScorer.js"(exports) {
    (function() {
      var computeScore, countDir, file_coeff, getExtension, getExtensionScore, isMatch, scorePath, scoreSize, tau_depth, _ref;
      _ref = require_scorer(), isMatch = _ref.isMatch, computeScore = _ref.computeScore, scoreSize = _ref.scoreSize;
      tau_depth = 20;
      file_coeff = 2.5;
      exports.score = function(string, query, options) {
        var allowErrors, preparedQuery, score, string_lw;
        preparedQuery = options.preparedQuery, allowErrors = options.allowErrors;
        if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {
          return 0;
        }
        string_lw = string.toLowerCase();
        score = computeScore(string, string_lw, preparedQuery);
        score = scorePath(string, string_lw, score, options);
        return Math.ceil(score);
      };
      scorePath = function(subject, subject_lw, fullPathScore, options) {
        var alpha, basePathScore, basePos, depth, end, extAdjust, fileLength, pathSeparator, preparedQuery, useExtensionBonus;
        if (fullPathScore === 0) {
          return 0;
        }
        preparedQuery = options.preparedQuery, useExtensionBonus = options.useExtensionBonus, pathSeparator = options.pathSeparator;
        end = subject.length - 1;
        while (subject[end] === pathSeparator) {
          end--;
        }
        basePos = subject.lastIndexOf(pathSeparator, end);
        fileLength = end - basePos;
        extAdjust = 1;
        if (useExtensionBonus) {
          extAdjust += getExtensionScore(subject_lw, preparedQuery.ext, basePos, end, 2);
          fullPathScore *= extAdjust;
        }
        if (basePos === -1) {
          return fullPathScore;
        }
        depth = preparedQuery.depth;
        while (basePos > -1 && depth-- > 0) {
          basePos = subject.lastIndexOf(pathSeparator, basePos - 1);
        }
        basePathScore = basePos === -1 ? fullPathScore : extAdjust * computeScore(subject.slice(basePos + 1, end + 1), subject_lw.slice(basePos + 1, end + 1), preparedQuery);
        alpha = 0.5 * tau_depth / (tau_depth + countDir(subject, end + 1, pathSeparator));
        return alpha * basePathScore + (1 - alpha) * fullPathScore * scoreSize(0, file_coeff * fileLength);
      };
      exports.countDir = countDir = function(path2, end, pathSeparator) {
        var count, i;
        if (end < 1) {
          return 0;
        }
        count = 0;
        i = -1;
        while (++i < end && path2[i] === pathSeparator) {
          continue;
        }
        while (++i < end) {
          if (path2[i] === pathSeparator) {
            count++;
            while (++i < end && path2[i] === pathSeparator) {
              continue;
            }
          }
        }
        return count;
      };
      exports.getExtension = getExtension = function(str) {
        var pos;
        pos = str.lastIndexOf(".");
        if (pos < 0) {
          return "";
        } else {
          return str.substr(pos + 1);
        }
      };
      getExtensionScore = function(candidate, ext, startPos, endPos, maxDepth) {
        var m, matched, n, pos;
        if (!ext.length) {
          return 0;
        }
        pos = candidate.lastIndexOf(".", endPos);
        if (!(pos > startPos)) {
          return 0;
        }
        n = ext.length;
        m = endPos - pos;
        if (m < n) {
          n = m;
          m = ext.length;
        }
        pos++;
        matched = -1;
        while (++matched < n) {
          if (candidate[pos + matched] !== ext[matched]) {
            break;
          }
        }
        if (matched === 0 && maxDepth > 0) {
          return 0.9 * getExtensionScore(candidate, ext, startPos, pos - 2, maxDepth - 1);
        }
        return matched / m;
      };
    }).call(exports);
  }
});

// node_modules/fuzzaldrin-plus/lib/query.js
var require_query = __commonJS({
  "node_modules/fuzzaldrin-plus/lib/query.js"(exports, module2) {
    (function() {
      var Query, coreChars, countDir, getCharCodes, getExtension, opt_char_re, truncatedUpperCase, _ref;
      _ref = require_pathScorer(), countDir = _ref.countDir, getExtension = _ref.getExtension;
      module2.exports = Query = function() {
        function Query2(query, _arg) {
          var optCharRegEx, pathSeparator, _ref1;
          _ref1 = _arg != null ? _arg : {}, optCharRegEx = _ref1.optCharRegEx, pathSeparator = _ref1.pathSeparator;
          if (!(query && query.length)) {
            return null;
          }
          this.query = query;
          this.query_lw = query.toLowerCase();
          this.core = coreChars(query, optCharRegEx);
          this.core_lw = this.core.toLowerCase();
          this.core_up = truncatedUpperCase(this.core);
          this.depth = countDir(query, query.length, pathSeparator);
          this.ext = getExtension(this.query_lw);
          this.charCodes = getCharCodes(this.query_lw);
        }
        return Query2;
      }();
      opt_char_re = /[ _\-:\/\\]/g;
      coreChars = function(query, optCharRegEx) {
        if (optCharRegEx == null) {
          optCharRegEx = opt_char_re;
        }
        return query.replace(optCharRegEx, "");
      };
      truncatedUpperCase = function(str) {
        var char, upper, _i, _len;
        upper = "";
        for (_i = 0, _len = str.length; _i < _len; _i++) {
          char = str[_i];
          upper += char.toUpperCase()[0];
        }
        return upper;
      };
      getCharCodes = function(str) {
        var charCodes, i, len;
        len = str.length;
        i = -1;
        charCodes = [];
        while (++i < len) {
          charCodes[str.charCodeAt(i)] = true;
        }
        return charCodes;
      };
    }).call(exports);
  }
});

// node_modules/fuzzaldrin-plus/lib/filter.js
var require_filter = __commonJS({
  "node_modules/fuzzaldrin-plus/lib/filter.js"(exports, module2) {
    (function() {
      var Query, pathScorer, pluckCandidates, scorer, sortCandidates;
      scorer = require_scorer();
      pathScorer = require_pathScorer();
      Query = require_query();
      pluckCandidates = function(a) {
        return a.candidate;
      };
      sortCandidates = function(a, b) {
        return b.score - a.score;
      };
      module2.exports = function(candidates, query, options) {
        var bKey, candidate, key, maxInners, maxResults, score, scoreProvider, scoredCandidates, spotLeft, string, usePathScoring, _i, _len;
        scoredCandidates = [];
        key = options.key, maxResults = options.maxResults, maxInners = options.maxInners, usePathScoring = options.usePathScoring;
        spotLeft = maxInners != null && maxInners > 0 ? maxInners : candidates.length + 1;
        bKey = key != null;
        scoreProvider = usePathScoring ? pathScorer : scorer;
        for (_i = 0, _len = candidates.length; _i < _len; _i++) {
          candidate = candidates[_i];
          string = bKey ? candidate[key] : candidate;
          if (!string) {
            continue;
          }
          score = scoreProvider.score(string, query, options);
          if (score > 0) {
            scoredCandidates.push({
              candidate,
              score
            });
            if (!--spotLeft) {
              break;
            }
          }
        }
        scoredCandidates.sort(sortCandidates);
        candidates = scoredCandidates.map(pluckCandidates);
        if (maxResults != null) {
          candidates = candidates.slice(0, maxResults);
        }
        return candidates;
      };
    }).call(exports);
  }
});

// node_modules/fuzzaldrin-plus/lib/matcher.js
var require_matcher = __commonJS({
  "node_modules/fuzzaldrin-plus/lib/matcher.js"(exports) {
    (function() {
      var basenameMatch, computeMatch, isMatch, isWordStart, match, mergeMatches, scoreAcronyms, scoreCharacter, scoreConsecutives, _ref;
      _ref = require_scorer(), isMatch = _ref.isMatch, isWordStart = _ref.isWordStart, scoreConsecutives = _ref.scoreConsecutives, scoreCharacter = _ref.scoreCharacter, scoreAcronyms = _ref.scoreAcronyms;
      exports.match = match = function(string, query, options) {
        var allowErrors, baseMatches, matches, pathSeparator, preparedQuery, string_lw;
        allowErrors = options.allowErrors, preparedQuery = options.preparedQuery, pathSeparator = options.pathSeparator;
        if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {
          return [];
        }
        string_lw = string.toLowerCase();
        matches = computeMatch(string, string_lw, preparedQuery);
        if (matches.length === 0) {
          return matches;
        }
        if (string.indexOf(pathSeparator) > -1) {
          baseMatches = basenameMatch(string, string_lw, preparedQuery, pathSeparator);
          matches = mergeMatches(matches, baseMatches);
        }
        return matches;
      };
      exports.wrap = function(string, query, options) {
        var matchIndex, matchPos, matchPositions, output, strPos, tagClass, tagClose, tagOpen, _ref1;
        if (options.wrap != null) {
          _ref1 = options.wrap, tagClass = _ref1.tagClass, tagOpen = _ref1.tagOpen, tagClose = _ref1.tagClose;
        }
        if (tagClass == null) {
          tagClass = "highlight";
        }
        if (tagOpen == null) {
          tagOpen = '<strong class="' + tagClass + '">';
        }
        if (tagClose == null) {
          tagClose = "</strong>";
        }
        if (string === query) {
          return tagOpen + string + tagClose;
        }
        matchPositions = match(string, query, options);
        if (matchPositions.length === 0) {
          return string;
        }
        output = "";
        matchIndex = -1;
        strPos = 0;
        while (++matchIndex < matchPositions.length) {
          matchPos = matchPositions[matchIndex];
          if (matchPos > strPos) {
            output += string.substring(strPos, matchPos);
            strPos = matchPos;
          }
          while (++matchIndex < matchPositions.length) {
            if (matchPositions[matchIndex] === matchPos + 1) {
              matchPos++;
            } else {
              matchIndex--;
              break;
            }
          }
          matchPos++;
          if (matchPos > strPos) {
            output += tagOpen;
            output += string.substring(strPos, matchPos);
            output += tagClose;
            strPos = matchPos;
          }
        }
        if (strPos <= string.length - 1) {
          output += string.substring(strPos);
        }
        return output;
      };
      basenameMatch = function(subject, subject_lw, preparedQuery, pathSeparator) {
        var basePos, depth, end;
        end = subject.length - 1;
        while (subject[end] === pathSeparator) {
          end--;
        }
        basePos = subject.lastIndexOf(pathSeparator, end);
        if (basePos === -1) {
          return [];
        }
        depth = preparedQuery.depth;
        while (depth-- > 0) {
          basePos = subject.lastIndexOf(pathSeparator, basePos - 1);
          if (basePos === -1) {
            return [];
          }
        }
        basePos++;
        end++;
        return computeMatch(subject.slice(basePos, end), subject_lw.slice(basePos, end), preparedQuery, basePos);
      };
      mergeMatches = function(a, b) {
        var ai, bj, i, j, m, n, out;
        m = a.length;
        n = b.length;
        if (n === 0) {
          return a.slice();
        }
        if (m === 0) {
          return b.slice();
        }
        i = -1;
        j = 0;
        bj = b[j];
        out = [];
        while (++i < m) {
          ai = a[i];
          while (bj <= ai && ++j < n) {
            if (bj < ai) {
              out.push(bj);
            }
            bj = b[j];
          }
          out.push(ai);
        }
        while (j < n) {
          out.push(b[j++]);
        }
        return out;
      };
      computeMatch = function(subject, subject_lw, preparedQuery, offset) {
        var DIAGONAL, LEFT, STOP, UP, acro_score, align, backtrack, csc_diag, csc_row, csc_score, i, j, m, matches, move, n, pos, query, query_lw, score, score_diag, score_row, score_up, si_lw, start, trace;
        if (offset == null) {
          offset = 0;
        }
        query = preparedQuery.query;
        query_lw = preparedQuery.query_lw;
        m = subject.length;
        n = query.length;
        acro_score = scoreAcronyms(subject, subject_lw, query, query_lw).score;
        score_row = new Array(n);
        csc_row = new Array(n);
        STOP = 0;
        UP = 1;
        LEFT = 2;
        DIAGONAL = 3;
        trace = new Array(m * n);
        pos = -1;
        j = -1;
        while (++j < n) {
          score_row[j] = 0;
          csc_row[j] = 0;
        }
        i = -1;
        while (++i < m) {
          score = 0;
          score_up = 0;
          csc_diag = 0;
          si_lw = subject_lw[i];
          j = -1;
          while (++j < n) {
            csc_score = 0;
            align = 0;
            score_diag = score_up;
            if (query_lw[j] === si_lw) {
              start = isWordStart(i, subject, subject_lw);
              csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);
              align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);
            }
            score_up = score_row[j];
            csc_diag = csc_row[j];
            if (score > score_up) {
              move = LEFT;
            } else {
              score = score_up;
              move = UP;
            }
            if (align > score) {
              score = align;
              move = DIAGONAL;
            } else {
              csc_score = 0;
            }
            score_row[j] = score;
            csc_row[j] = csc_score;
            trace[++pos] = score > 0 ? move : STOP;
          }
        }
        i = m - 1;
        j = n - 1;
        pos = i * n + j;
        backtrack = true;
        matches = [];
        while (backtrack && i >= 0 && j >= 0) {
          switch (trace[pos]) {
            case UP:
              i--;
              pos -= n;
              break;
            case LEFT:
              j--;
              pos--;
              break;
            case DIAGONAL:
              matches.push(i + offset);
              j--;
              i--;
              pos -= n + 1;
              break;
            default:
              backtrack = false;
          }
        }
        matches.reverse();
        return matches;
      };
    }).call(exports);
  }
});

// node_modules/fuzzaldrin-plus/lib/fuzzaldrin.js
var require_fuzzaldrin = __commonJS({
  "node_modules/fuzzaldrin-plus/lib/fuzzaldrin.js"(exports, module2) {
    (function() {
      var Query, defaultPathSeparator, filter2, matcher, parseOptions, pathScorer, preparedQueryCache, scorer;
      filter2 = require_filter();
      matcher = require_matcher();
      scorer = require_scorer();
      pathScorer = require_pathScorer();
      Query = require_query();
      preparedQueryCache = null;
      defaultPathSeparator = (typeof process !== "undefined" && process !== null ? process.platform : void 0) === "win32" ? "\\" : "/";
      module2.exports = {
        filter: function(candidates, query, options) {
          if (options == null) {
            options = {};
          }
          if (!((query != null ? query.length : void 0) && (candidates != null ? candidates.length : void 0))) {
            return [];
          }
          options = parseOptions(options, query);
          return filter2(candidates, query, options);
        },
        score: function(string, query, options) {
          if (options == null) {
            options = {};
          }
          if (!((string != null ? string.length : void 0) && (query != null ? query.length : void 0))) {
            return 0;
          }
          options = parseOptions(options, query);
          if (options.usePathScoring) {
            return pathScorer.score(string, query, options);
          } else {
            return scorer.score(string, query, options);
          }
        },
        match: function(string, query, options) {
          var _i, _ref, _results;
          if (options == null) {
            options = {};
          }
          if (!string) {
            return [];
          }
          if (!query) {
            return [];
          }
          if (string === query) {
            return function() {
              _results = [];
              for (var _i2 = 0, _ref2 = string.length; 0 <= _ref2 ? _i2 < _ref2 : _i2 > _ref2; 0 <= _ref2 ? _i2++ : _i2--) {
                _results.push(_i2);
              }
              return _results;
            }.apply(this);
          }
          options = parseOptions(options, query);
          return matcher.match(string, query, options);
        },
        wrap: function(string, query, options) {
          if (options == null) {
            options = {};
          }
          if (!string) {
            return [];
          }
          if (!query) {
            return [];
          }
          options = parseOptions(options, query);
          return matcher.wrap(string, query, options);
        },
        prepareQuery: function(query, options) {
          if (options == null) {
            options = {};
          }
          options = parseOptions(options, query);
          return options.preparedQuery;
        }
      };
      parseOptions = function(options, query) {
        if (options.allowErrors == null) {
          options.allowErrors = false;
        }
        if (options.usePathScoring == null) {
          options.usePathScoring = true;
        }
        if (options.useExtensionBonus == null) {
          options.useExtensionBonus = false;
        }
        if (options.pathSeparator == null) {
          options.pathSeparator = defaultPathSeparator;
        }
        if (options.optCharRegEx == null) {
          options.optCharRegEx = null;
        }
        if (options.wrap == null) {
          options.wrap = null;
        }
        if (options.preparedQuery == null) {
          options.preparedQuery = preparedQueryCache && preparedQueryCache.query === query ? preparedQueryCache : preparedQueryCache = new Query(query, options);
        }
        return options;
      };
    }).call(exports);
  }
});

// node_modules/shell-escape/shell-escape.js
var require_shell_escape = __commonJS({
  "node_modules/shell-escape/shell-escape.js"(exports, module2) {
    module2.exports = shellescape;
    function shellescape(a) {
      var ret = [];
      a.forEach(function(s) {
        if (!/^[A-Za-z0-9_\/-]+$/.test(s)) {
          s = "'" + s.replace(/'/g, "'\\''") + "'";
          s = s.replace(/^(?:'')+/g, "").replace(/\\'''/g, "\\'");
        }
        ret.push(s);
      });
      return ret.join(" ");
    }
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FabricPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_child_process = require("child_process");
var import_util = require("util");
var path = __toESM(require("path"));
var fuzzaldrin = __toESM(require_fuzzaldrin());
var shellEscape = require_shell_escape();
var execAsync = (0, import_util.promisify)(import_child_process.exec);
var DEFAULT_SETTINGS = {
  fabricConnectorApiUrl: "",
  fabricConnectorApiKey: "",
  outputFolder: "",
  customPatternsFolder: "",
  youtubeAutodetectEnabled: true,
  audioFileAutodetectEnabled: true,
  defaultModel: "gpt-4o",
  defaultPostProcessingPattern: "",
  debug: false,
  fabric2: false,
  tavilyApiKey: ""
};
var FabricPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.customPatternsFolder = null;
    this.patterns = [];
    this.isLogging = false;
    this.handleFileDeletion = (file) => {
      this.log(`File deletion detected: ${file.path}`);
      this.log(`Custom patterns folder: ${this.settings.customPatternsFolder}`);
      if (!(file instanceof import_obsidian.TFile)) {
        this.log("Deleted item is not a file");
        return;
      }
      const customPatternsPath = this.settings.customPatternsFolder.endsWith("/") ? this.settings.customPatternsFolder : this.settings.customPatternsFolder + "/";
      if (!file.path.startsWith(customPatternsPath)) {
        this.log("File is not in the custom patterns folder");
        return;
      }
      if (file.extension !== "md") {
        this.log("File is not a markdown file");
        return;
      }
      this.log(`Markdown file deleted in custom patterns folder: ${file.path}`);
      this.handleCustomPatternDeletion(file.name);
    };
  }
  async onload() {
    await this.loadSettings();
    this.updateLogging();
    await this.checkAndDownloadLogo();
    await this.loadSettings();
    this.registerCustomPatternsFolderWatcher();
    this.app.workspace.onLayoutReady(() => {
      this.registerCustomPatternsFolderWatcher();
    });
    this.addCommand({
      id: "open-community-patterns",
      name: "Open Community Patterns",
      callback: () => {
        new CommunityPatternsModal(this.app, this).open();
      }
    });
    this.addSettingTab(new FabricSettingTab(this.app, this));
    this.registerView(
      "fabric-view",
      (leaf) => new FabricView(
        leaf,
        this,
        this.settings.fabricConnectorApiUrl,
        this.settings.fabricConnectorApiKey
      )
    );
    if (this.app.workspace.layoutReady) {
      this.initLeaf();
    } else {
      this.app.workspace.onLayoutReady(this.initLeaf.bind(this));
    }
    this.addRibbonIcon("brain", "Fabric", () => {
      this.activateView();
    });
  }
  log(message, ...args) {
    if (this.settings.debug && !this.isLogging) {
      this.isLogging = true;
      console.log(`[Fabric Debug] ${message}`, ...args);
      this.isLogging = false;
    }
  }
  initLeaf() {
    if (this.app.workspace.getLeavesOfType("fabric-view").length) {
      return;
    }
    const rightLeaf = this.app.workspace.getRightLeaf(false);
    if (rightLeaf) {
      rightLeaf.setViewState({
        type: "fabric-view",
        active: true
      });
    }
  }
  updateLogging() {
    if (this.settings.debug) {
      console.log("[Fabric] Debug mode enabled");
    } else {
      console.log("[Fabric] Debug mode disabled");
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  registerCustomPatternsFolderWatcher() {
    this.log("Registering custom patterns folder watcher");
    this.app.vault.off("delete", this.handleFileDeletion);
    if (this.settings.customPatternsFolder) {
      const folderPath = this.settings.customPatternsFolder.endsWith("/") ? this.settings.customPatternsFolder : this.settings.customPatternsFolder + "/";
      this.log(`Watching for deletions in: ${folderPath}`);
      this.registerEvent(
        this.app.vault.on("delete", this.handleFileDeletion)
      );
    } else {
      console.warn("Custom patterns folder path not set in settings");
    }
  }
  async handleCustomPatternDeletion(fileName) {
    this.log(`Handling custom pattern deletion for: ${fileName}`);
    const patternName = fileName.replace(".md", "");
    const confirmDelete = await this.confirmPatternDeletion(patternName);
    if (confirmDelete) {
      await this.deletePatternFromFabric(patternName);
    }
  }
  async checkAndDownloadLogo() {
    if (!this.manifest.dir) {
      console.error("Plugin directory is undefined");
      return;
    }
    const logoPath = path.join(this.manifest.dir, "fabric-logo-gif.gif");
    const logoExists = await this.app.vault.adapter.exists(logoPath);
    if (!logoExists) {
      try {
        const logoUrl = "https://raw.githubusercontent.com/chasebank87/unofficial-fabric-plugin/main/fabric-logo-gif.gif";
        const response = await fetch(logoUrl);
        if (!response.ok)
          throw new Error("Failed to fetch logo");
        const arrayBuffer = await response.arrayBuffer();
        const buffer = new Uint8Array(arrayBuffer);
        await this.app.vault.adapter.writeBinary(logoPath, buffer);
        this.log("Fabric logo downloaded successfully");
      } catch (error) {
        console.error("Error downloading Fabric logo:", error);
      }
    }
  }
  async confirmPatternDeletion(patternName) {
    return new Promise((resolve) => {
      const notice = new import_obsidian.Notice("", 0);
      const container = notice.noticeEl.createDiv("fabric-confirm-deletion");
      container.createEl("h3", { text: "Confirm Pattern Deletion" });
      container.createEl("p", { text: `Do you want to delete the pattern "${patternName}" and its folder from Fabric as well?` });
      const buttonContainer = container.createDiv("fabric-confirm-buttons");
      const yesButton = buttonContainer.createEl("button", { text: "Yes" });
      yesButton.onclick = () => {
        notice.hide();
        resolve(true);
      };
      const noButton = buttonContainer.createEl("button", { text: "No" });
      noButton.onclick = () => {
        notice.hide();
        resolve(false);
      };
    });
  }
  async deletePatternFromFabric(patternName) {
    try {
      const response = await fetch(this.settings.fabricConnectorApiUrl + "/delete_pattern", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-API-Key": this.settings.fabricConnectorApiKey
          // Add the Fabric Connector API Key here
        },
        body: JSON.stringify({ pattern: patternName })
      });
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const result = await response.json();
      new import_obsidian.Notice(result.message);
      await this.updateFabricView();
    } catch (error) {
      console.error("Error deleting pattern from Fabric:", error);
      new import_obsidian.Notice(`Failed to delete pattern "${patternName}" from Fabric.`);
    }
  }
  updateFabricView() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view instanceof FabricView) {
        leaf.view.loadPatterns();
      }
    });
  }
  async getDefaultShell() {
    if (import_obsidian.Platform.isWin) {
      return "cmd.exe";
    }
    try {
      const { stdout } = await execAsync("echo $SHELL");
      return stdout.trim();
    } catch (error) {
      console.error("Failed to detect default shell:", error);
      return "/bin/sh";
    }
  }
  async activateView() {
    this.app.workspace.detachLeavesOfType("fabric-view");
    const rightLeaf = this.app.workspace.getRightLeaf(false);
    if (rightLeaf) {
      rightLeaf.setViewState({
        type: "fabric-view",
        active: true
      });
    }
    this.app.workspace.revealLeaf(
      this.app.workspace.getLeavesOfType("fabric-view")[0]
    );
  }
};
var FabricView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin, fabricConnectorApiUrl, fabricConnectorApiKey) {
    super(leaf);
    this.patterns = [];
    this.selectedOptionIndex = -1;
    this.models = [];
    this.selectedModelIndex = -1;
    this.selectedPatterns = [];
    this.loadingMessages = [
      "reticulating splines...",
      "engaging warp drive...",
      "calibrating flux capacitor...",
      "compiling techno-babble...",
      "reversing the polarity...",
      "bypassing the mainframe...",
      "initializing neural network...",
      "decrypting alien transmissions...",
      "charging photon torpedoes...",
      "hacking the gibson...",
      "Warming flux capacitor...",
      "Downloading more RAM...",
      "Reversing neutron flow...",
      "Initializing sass protocol...",
      "Calibrating sarcasm sensors...",
      "Bypassing laws of physics...",
      "Generating witty message...",
      "Spinning hamster wheels...",
      "Charging sonic screwdriver...",
      "Aligning the stars...",
      "Dividing by zero...",
      "Upgrading to Windows 9...",
      "Searching for life's meaning...",
      "Awaiting the Singularity...",
      "Tuning alien frequencies...",
      "Bending space-time continuum...",
      "Compiling crash excuses...",
      "Calculating success probability...",
      "Rolling for initiative...",
      "Initiating self-destruct sequence...",
      "Summoning IT gods...",
      "Applying warp core tape...",
      "Translating binary to dance...",
      "Charging Arc Reactor..."
    ];
    this.plugin = plugin;
    this.fabricConnectorApiUrl = fabricConnectorApiUrl;
    this.fabricConnectorApiKey = fabricConnectorApiKey;
  }
  getViewType() {
    return "fabric-view";
  }
  getDisplayText() {
    return "Fabric";
  }
  showCommunityPatternsModal() {
    new CommunityPatternsModal(this.app, this.plugin).open();
  }
  async onOpen() {
    this.containerEl = this.contentEl;
    this.containerEl.empty();
    this.containerEl.addClass("fabric-view");
    this.logoContainer = this.containerEl.createEl("div", { cls: "fabric-logo-container" });
    let logoPath;
    if (this.plugin.manifest && this.plugin.manifest.dir) {
      logoPath = path.join(this.plugin.manifest.dir, "fabric-logo-gif.gif");
      const logoSrc2 = this.app.vault.adapter.getResourcePath(logoPath);
    } else {
      logoPath = "https://raw.githubusercontent.com/chasebank87/unofficial-fabric-plugin/main/fabric-logo-gif.gif";
    }
    const logoSrc = this.app.vault.adapter.getResourcePath(logoPath);
    const logo = this.logoContainer.createEl("img", {
      cls: "fabric-logo",
      attr: { src: logoSrc }
    });
    this.loadingText = this.logoContainer.createEl("h6", { cls: "fabric-loading-text" });
    const contentContainer = this.containerEl.createEl("div", { cls: "fabric-content" });
    const ytToggleContainer = contentContainer.createEl("div", { cls: "fabric-yt-toggle-container" });
    const tsToggleContainer = contentContainer.createEl("div", { cls: "fabric-ts-toggle-container" });
    this.ytToggle = ytToggleContainer.createEl("div", {
      cls: `fabric-yt-toggle ${this.plugin.settings.youtubeAutodetectEnabled ? "active" : ""}`
    });
    const toggleSlider = this.ytToggle.createEl("span", { cls: "fabric-yt-toggle-slider" });
    const ytLabel = ytToggleContainer.createEl("span", {
      cls: "fabric-yt-label",
      text: "YouTube Links"
    });
    this.tsToggle = tsToggleContainer.createEl("div", {
      cls: `fabric-ts-toggle ${this.plugin.settings.audioFileAutodetectEnabled ? "active" : ""}`
    });
    const toggleSliderTS = this.tsToggle.createEl("span", { cls: "fabric-ts-toggle-slider" });
    const tsLabel = tsToggleContainer.createEl("span", {
      cls: "fabric-ts-label",
      text: "Audio Files"
    });
    contentContainer.createEl("h3", { text: "fabric", cls: "fabric-title" });
    this.buttonsContainer = contentContainer.createEl("div", { cls: "fabric-buttons" });
    const currentNoteBtn = this.buttonsContainer.createEl("button", { text: "Current note", cls: "fabric-button current-note" });
    const clipboardBtn = this.buttonsContainer.createEl("button", { text: "Clipboard", cls: "fabric-button clipboard" });
    const tavilyBtn = this.buttonsContainer.createEl("button", { text: "Tavily", cls: "fabric-button tavily" });
    tavilyBtn.onclick = () => this.showTavilySearchModal();
    currentNoteBtn.onclick = () => this.runFabric("current");
    clipboardBtn.onclick = () => this.runFabric("clipboard");
    const inputsContainer = contentContainer.createEl("div", { cls: "fabric-inputs-container" });
    this.outputNoteInput = inputsContainer.createEl("input", {
      cls: "fabric-input",
      attr: { type: "text", placeholder: "Output note name" }
    });
    this.searchInput = inputsContainer.createEl("input", {
      cls: "fabric-input",
      attr: { type: "text", placeholder: "Search patterns..." }
    });
    this.modelSearchInput = inputsContainer.createEl("input", {
      cls: "fabric-input",
      attr: {
        type: "text",
        placeholder: "Search models..."
      }
    });
    this.patternDropdown = contentContainer.createEl("div", { cls: "fabric-dropdown", attr: { id: "pattern-dropdown", multiple: "true" } });
    this.modelDropdown = contentContainer.createEl("div", { cls: "fabric-dropdown", attr: { id: "model-dropdown" } });
    this.searchInput.addEventListener("blur", () => {
      setTimeout(() => {
        this.patternDropdown.empty();
        this.selectedOptionIndex = -1;
      }, 200);
    });
    this.searchInput.addEventListener("input", () => {
      const inputValue = this.searchInput.value;
      const patterns = inputValue.split(",").map((p) => p.trim()).filter((p) => p !== "");
      const selectedPatterns = patterns.slice(0, -1);
      const searchTerm = patterns[patterns.length - 1] || "";
      this.selectedPatterns = selectedPatterns.slice(0, 5);
      this.updatePatternOptions(searchTerm.toLowerCase());
    });
    this.modelSearchInput.addEventListener("input", () => {
      this.updateModelOptions(this.modelSearchInput.value.toLowerCase());
      this.updatePoweredByText(this.modelSearchInput.value);
    });
    this.searchInput.addEventListener("keydown", (event) => {
      this.handlePatternDropdownNavigation(event, this.patternDropdown, this.searchInput);
    });
    this.modelSearchInput.addEventListener("keydown", (event) => {
      this.handleDropdownNavigation(event, this.modelDropdown, this.modelSearchInput);
    });
    this.defaultModelDisplay = contentContainer.createEl("div", { cls: "fabric-default-model" });
    this.defaultModelDisplay.createSpan({ text: "Powered by " });
    this.modelNameSpan = this.defaultModelDisplay.createSpan({ cls: "model-name" });
    this.updatePoweredByText(this.plugin.settings.defaultModel || "No default model set");
    this.searchInput.addEventListener("focus", () => {
      this.searchInput.classList.add("active");
    });
    this.searchInput.addEventListener("blur", () => {
      this.searchInput.classList.remove("active");
    });
    this.outputNoteInput.addEventListener("focus", () => {
      this.outputNoteInput.classList.add("active");
    });
    this.outputNoteInput.addEventListener("blur", () => {
      this.outputNoteInput.classList.remove("active");
    });
    this.ytToggle.addEventListener("click", () => {
      this.ytToggle.classList.toggle("active");
      this.plugin.settings.youtubeAutodetectEnabled = this.ytToggle.classList.contains("active");
      this.plugin.saveSettings();
      if (this.plugin.settings.youtubeAutodetectEnabled) {
        new import_obsidian.Notice("YouTube link detection enabled");
      } else {
        new import_obsidian.Notice("YouTube link detection disabled");
      }
    });
    this.tsToggle.addEventListener("click", () => {
      this.tsToggle.classList.toggle("active");
      this.plugin.settings.audioFileAutodetectEnabled = this.tsToggle.classList.contains("active");
      this.plugin.saveSettings();
      if (this.plugin.settings.audioFileAutodetectEnabled) {
        new import_obsidian.Notice("Audio file detection enabled");
      } else {
        new import_obsidian.Notice("Audio file link detection disabled");
      }
    });
    currentNoteBtn.onclick = () => this.handleFabricRun("current");
    clipboardBtn.onclick = () => this.handleFabricRun("clipboard");
    const buttonContainer = contentContainer.createEl("div", { cls: "fabric-button-container" });
    this.refreshButton = buttonContainer.createEl("button", {
      cls: "fabric-icon-button fabric-refresh-button",
      attr: {
        "aria-label": "Refresh patterns and models"
      }
    });
    (0, import_obsidian.setIcon)(this.refreshButton, "refresh-cw");
    this.refreshButton.onclick = async () => {
      await this.loadPatterns();
      await this.loadModels();
      new import_obsidian.Notice("Patterns and models refreshed");
    };
    this.syncButton = buttonContainer.createEl("button", {
      cls: "fabric-icon-button fabric-sync-button",
      attr: {
        "aria-label": "Sync custom patterns"
      }
    });
    (0, import_obsidian.setIcon)(this.syncButton, "upload-cloud");
    this.syncButton.onclick = async () => {
      await this.syncCustomPatterns();
    };
    this.communityPatternsBtn = contentContainer.createEl("button", {
      cls: "fabric-icon-button  community-patterns",
      attr: {
        "aria-label": "Download community patterns"
      }
    });
    (0, import_obsidian.setIcon)(this.communityPatternsBtn, "download");
    this.communityPatternsBtn.onclick = () => this.showCommunityPatternsModal();
    this.progressSpinner = contentContainer.createEl("div", { cls: "fabric-progress-spinner" });
    await this.loadPatterns();
    await this.loadModels();
    this.updatePatternOptions("");
    this.updateModelOptions("");
    this.searchInput.focus();
  }
  showTavilySearchModal() {
    const pattern = this.searchInput.value.trim();
    const model = this.getCurrentModel();
    if (!model) {
      new import_obsidian.Notice("Please select a model or set a default model in settings before running.");
      return;
    }
    if (!pattern) {
      new import_obsidian.Notice("Please select a pattern first");
      return;
    }
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText("Tavily Search");
    const { contentEl } = modal;
    contentEl.addClass("fabric-tavily-modal");
    const searchInput = contentEl.createEl("input", {
      type: "text",
      placeholder: "Enter your search query"
    });
    searchInput.addClass("fabric-tavily-input");
    const searchButton = contentEl.createEl("button", {
      text: "Search",
      cls: "mod-cta"
    });
    searchButton.addClass("fabric-tavily-search-button");
    searchButton.onclick = async () => {
      const query = searchInput.value.trim();
      if (query) {
        modal.close();
        await this.performTavilySearch(query);
      } else {
        new import_obsidian.Notice("Please enter a search query");
      }
    };
    modal.open();
  }
  async performTavilySearch(query) {
    this.logoContainer.addClass("loading");
    this.loadingText.setText("");
    this.animateLoadingText("Searching Tavily...");
    try {
      const response = await fetch("https://api.tavily.com/search", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          query,
          include_answer: true,
          max_results: 5,
          include_images: true,
          search_depth: "basic",
          api_key: this.plugin.settings.tavilyApiKey
        })
      });
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      const searchResult = JSON.stringify(data) + "\n";
      await this.runFabricWithTavilyResult(searchResult);
    } catch (error) {
      console.error("Failed to perform Tavily search:", error);
      new import_obsidian.Notice("Failed to perform Tavily search. Please check your API key and try again.");
    } finally {
      this.logoContainer.removeClass("loading");
      this.loadingText.setText("");
    }
  }
  async runFabricWithTavilyResult(searchResult) {
    if (this.plugin.settings.defaultPostProcessingPattern) {
      this.selectedPatterns.push(this.plugin.settings.defaultPostProcessingPattern);
    }
    const pattern = this.selectedPatterns;
    const model = this.getCurrentModel();
    let outputNoteName = this.outputNoteInput.value.trim();
    if (!model) {
      new import_obsidian.Notice("Please select a model or set a default model in settings before running.");
      return;
    }
    if (!pattern) {
      new import_obsidian.Notice("Please select a pattern first");
      return;
    }
    try {
      const response = await fetch(this.plugin.settings.fabricConnectorApiUrl + "/fabric", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json",
          "X-API-Key": this.plugin.settings.fabricConnectorApiKey
        },
        body: JSON.stringify({
          pattern,
          model,
          data: searchResult,
          stream: true,
          goCompatibility: this.plugin.settings.fabric2
        })
      });
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const responseData = await response.json();
      const output = responseData.output;
      const newFile = await this.createOutputNote(output, outputNoteName);
      new import_obsidian.Notice("Fabric output generated successfully with Tavily search result");
    } catch (error) {
      console.error("Failed to run fabric with Tavily result:", error);
      new import_obsidian.Notice("Failed to run fabric with Tavily result. Please check your settings and try again.");
    }
  }
  async runFabric(source) {
    let data = "";
    let pattern = this.selectedPatterns;
    let outputNoteName = this.outputNoteInput.value.trim();
    const model = this.getCurrentModel();
    if (!model) {
      new import_obsidian.Notice("Please select a model or set a default model in settings before running.");
      return;
    }
    if (source === "current") {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile) {
        data = await this.app.vault.read(activeFile) + "\n";
      }
    } else if (source === "clipboard") {
      data = await navigator.clipboard.readText() + "\n";
    } else if (source === "pattern") {
      if (!pattern) {
        new import_obsidian.Notice("Please select a pattern first");
        return;
      }
    }
    this.logoContainer.addClass("loading");
    this.loadingText.setText("");
    this.animateLoadingText(this.getRandomLoadingMessage());
    try {
      const response = await fetch(this.plugin.settings.fabricConnectorApiUrl + "/fabric", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json",
          "X-API-Key": this.plugin.settings.fabricConnectorApiKey
        },
        body: JSON.stringify({
          pattern,
          model,
          data,
          stream: true,
          goCompatibility: this.plugin.settings.fabric2
        })
      });
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const responseData = await response.json();
      const output = responseData.output;
      const newFile = await this.createOutputNote(output, outputNoteName);
      this.logoContainer.removeClass("loading");
      this.loadingText.setText("");
      new import_obsidian.Notice("Fabric output generated successfully");
    } catch (error) {
      console.error("Failed to run fabric:", error);
      this.logoContainer.removeClass("loading");
      this.loadingText.setText("");
      new import_obsidian.Notice("Failed to run fabric. Please check your settings and try again.");
    }
  }
  getRandomLoadingMessage() {
    return this.loadingMessages[Math.floor(Math.random() * this.loadingMessages.length)];
  }
  animateLoadingText(text) {
    let i = 0;
    const intervalId = setInterval(() => {
      if (!this.logoContainer.hasClass("loading")) {
        clearInterval(intervalId);
        return;
      }
      if (i < text.length) {
        this.loadingText.setText(this.loadingText.getText() + text[i]);
        i++;
      } else {
        setTimeout(() => {
          this.loadingText.setText("");
          i = 0;
        }, 1e3);
      }
    }, 100);
  }
  async createOutputNote(content, noteName) {
    let fileName = `${noteName}.md`;
    let filePath = path.join(this.plugin.settings.outputFolder, fileName);
    let fileExists = await this.app.vault.adapter.exists(filePath);
    let counter = 1;
    while (fileExists) {
      fileName = `${noteName} (${counter}).md`;
      filePath = path.join(this.plugin.settings.outputFolder, fileName);
      fileExists = await this.app.vault.adapter.exists(filePath);
      counter++;
    }
    const newFile = await this.app.vault.create(filePath, content);
    const activeLeaf = this.app.workspace.getMostRecentLeaf();
    if (activeLeaf && !activeLeaf.getViewState().pinned) {
      const newLeaf = this.app.workspace.createLeafBySplit(activeLeaf, "vertical");
      await newLeaf.openFile(newFile);
    } else {
      const newLeaf = this.app.workspace.getLeaf("tab");
      await newLeaf.openFile(newFile);
    }
    return newFile;
  }
  updatePatternOptions(query) {
    this.patternDropdown.empty();
    this.selectedOptionIndex = -1;
    const filteredPatterns = query ? fuzzaldrin.filter(this.patterns, query) : this.patterns;
    if (filteredPatterns.length === 0) {
      this.patternDropdown.createEl("div", {
        cls: "fabric-dropdown-option",
        text: "No patterns found"
      });
    } else {
      filteredPatterns.forEach((pattern, index) => {
        this.addPatternOption(pattern, index);
      });
    }
    if (this.patternDropdown.children.length > 0) {
      this.selectedOptionIndex = 0;
      this.updateSelectedOption(this.patternDropdown.querySelectorAll(".fabric-dropdown-option"));
    }
  }
  addPatternOption(pattern, index) {
    const option = this.patternDropdown.createEl("div", {
      cls: `fabric-dropdown-option ${index === 0 ? "selected" : ""}`,
      text: pattern
    });
    option.addEventListener("mousedown", (event) => {
      event.preventDefault();
    });
    option.addEventListener("click", (event) => {
      event.preventDefault();
      this.selectPattern(pattern);
      this.searchInput.focus();
    });
  }
  selectPattern(pattern) {
    if (this.selectedPatterns.length >= 5 && !this.selectedPatterns.includes(pattern)) {
      new import_obsidian.Notice("You can only select up to 5 patterns.");
      return;
    }
    if (!this.selectedPatterns.includes(pattern)) {
      this.selectedPatterns.push(pattern);
    }
    this.searchInput.value = this.selectedPatterns.join(", ") + (this.selectedPatterns.length > 0 ? ", " : "");
    this.updatePatternOptions("");
    this.searchInput.focus();
    const len = this.searchInput.value.length;
    this.searchInput.setSelectionRange(len, len);
  }
  updateSelectedOption(options) {
    options.forEach((option, index) => {
      if (index === this.selectedOptionIndex) {
        option.classList.add("selected");
        option.scrollIntoView({ block: "nearest" });
      } else {
        option.classList.remove("selected");
      }
    });
  }
  updateModelOptions(query) {
    this.modelDropdown.empty();
    this.selectedModelIndex = -1;
    if (query === "")
      return;
    const filteredModels = fuzzaldrin.filter(this.models, query);
    if (filteredModels.length === 0 && query !== "") {
      this.modelDropdown.createEl("div", {
        cls: "fabric-dropdown-option",
        text: "No models found"
      });
    } else {
      filteredModels.forEach((model, index) => {
        const option = this.modelDropdown.createEl("div", {
          cls: `fabric-dropdown-option ${index === 0 ? "selected" : ""}`,
          text: model
        });
        option.addEventListener("click", () => {
          this.selectModel(model);
        });
      });
      this.selectedModelIndex = 0;
    }
  }
  selectModel(model) {
    this.modelSearchInput.value = model;
    this.modelDropdown.empty();
    this.updatePoweredByText(model);
  }
  updatePoweredByText(model) {
    const displayModel = model || this.plugin.settings.defaultModel || "No model selected";
    if (this.modelNameSpan.textContent !== displayModel) {
      this.modelNameSpan.setText(displayModel);
      this.modelNameSpan.addClass("updating");
      setTimeout(() => {
        this.modelNameSpan.removeClass("updating");
      }, 500);
    }
  }
  updateDefaultModelDisplay() {
    this.updatePoweredByText(this.modelSearchInput.value);
  }
  getCurrentModel() {
    return this.modelSearchInput.value || this.plugin.settings.defaultModel;
  }
  async loadModels() {
    try {
      const url = new URL(this.plugin.settings.fabricConnectorApiUrl + "/models");
      url.searchParams.append("goCompatibility", this.plugin.settings.fabric2.toString());
      const response = await fetch(url, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          "X-API-Key": this.plugin.settings.fabricConnectorApiKey
        }
      });
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      this.models = data.data.models.map((model) => model.name);
      this.plugin.log("Models loaded:", this.models);
      this.updateDefaultModelDisplay();
    } catch (error) {
      this.plugin.log("Failed to load models from API:", error);
      new import_obsidian.Notice("Failed to load models. Please check the API server.");
    }
  }
  handleDropdownNavigation(event, dropdown, input) {
    switch (event.key) {
      case "ArrowDown":
        event.preventDefault();
        this.navigateDropdownOptions(1, dropdown);
        break;
      case "ArrowUp":
        event.preventDefault();
        this.navigateDropdownOptions(-1, dropdown);
        break;
      case "Enter":
        event.preventDefault();
        this.selectCurrentOption(dropdown, input);
        break;
    }
  }
  handlePatternDropdownNavigation(event, dropdown, input) {
    const options = dropdown.querySelectorAll(".fabric-dropdown-option");
    switch (event.key) {
      case "ArrowDown":
        event.preventDefault();
        this.selectedOptionIndex = Math.min(this.selectedOptionIndex + 1, options.length - 1);
        this.updateSelectedOption(options);
        break;
      case "ArrowUp":
        event.preventDefault();
        this.selectedOptionIndex = Math.max(this.selectedOptionIndex - 1, 0);
        this.updateSelectedOption(options);
        break;
      case "Enter":
        event.preventDefault();
        if (this.selectedOptionIndex >= 0 && this.selectedOptionIndex < options.length) {
          const selectedPattern = options[this.selectedOptionIndex].textContent;
          if (selectedPattern) {
            this.selectPattern(selectedPattern);
            this.updatePatternOptions("");
          }
        }
        break;
      case "Escape":
        event.preventDefault();
        dropdown.empty();
        this.selectedOptionIndex = -1;
        break;
    }
  }
  navigateDropdownOptions(direction, dropdown) {
    const options = Array.from(dropdown.children);
    const optionsCount = options.length;
    if (optionsCount === 0)
      return;
    const currentIndex = dropdown === this.patternDropdown ? this.selectedOptionIndex : this.selectedModelIndex;
    const newIndex = (currentIndex + direction + optionsCount) % optionsCount;
    options.forEach((option, index) => {
      if (index === newIndex) {
        option.classList.add("selected");
      } else {
        option.classList.remove("selected");
      }
    });
    if (dropdown === this.patternDropdown) {
      this.selectedOptionIndex = newIndex;
    } else {
      this.selectedModelIndex = newIndex;
    }
  }
  selectCurrentOption(dropdown, input) {
    const index = dropdown === this.modelDropdown ? this.selectedModelIndex : this.selectedOptionIndex;
    const selectedOption = dropdown.children[index];
    if (selectedOption) {
      const value = selectedOption.textContent;
      if (dropdown === this.modelDropdown) {
        this.selectModel(value);
      } else {
        input.value = value;
        dropdown.empty();
      }
    }
  }
  async loadPatterns() {
    try {
      const url = new URL(this.plugin.settings.fabricConnectorApiUrl + "/patterns");
      url.searchParams.append("goCompatibility", this.plugin.settings.fabric2.toString());
      const response = await fetch(url, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          "X-API-Key": this.plugin.settings.fabricConnectorApiKey
        }
      });
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      this.patterns = data.data.patterns.map((pattern) => pattern.name);
      this.plugin.log("Patterns loaded:", this.patterns);
    } catch (error) {
      this.plugin.log("Failed to load patterns from API:", error);
      new import_obsidian.Notice("Failed to load patterns. Please check the API server.");
    }
  }
  async handleFabricRun(source) {
    if (this.plugin.settings.defaultPostProcessingPattern) {
      this.selectedPatterns.push(this.plugin.settings.defaultPostProcessingPattern);
    }
    if (this.ytToggle.classList.contains("active") && this.tsToggle.classList.contains("active")) {
      const links = await this.extractYouTubeLinks(source);
      const paths = await this.extractAudioFiles(source);
      if (links.length > 0 && paths.length > 0) {
        new import_obsidian.Notice("Both YouTube links and audio files found. This is not supported yet. Try using clipboard.");
        this.runFabric(source);
        return;
      }
      if (links.length > 0) {
        this.showYouTubeModal(links, source);
      } else if (paths.length > 0) {
        this.showAudioModal(paths, source);
      } else {
        new import_obsidian.Notice("No YouTube links or audio files found. Running Fabric normally.");
        this.runFabric(source);
      }
    } else if (this.tsToggle.classList.contains("active")) {
      const links = await this.extractAudioFiles(source);
      if (links.length > 0) {
        this.showAudioModal(links, source);
      } else {
        new import_obsidian.Notice("No audio files found. Running Fabric normally.");
        this.runFabric(source);
      }
    } else if (this.ytToggle.classList.contains("active")) {
      const links = await this.extractYouTubeLinks(source);
      if (links.length > 0) {
        this.showYouTubeModal(links, source);
      } else {
        new import_obsidian.Notice("No YouTube links found. Running Fabric normally.");
        this.runFabric(source);
      }
    } else {
      this.runFabric(source);
    }
  }
  async extractYouTubeLinks(source) {
    let text = "";
    if (source === "current") {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile) {
        text = await this.app.vault.read(activeFile);
      }
    } else {
      text = await navigator.clipboard.readText();
    }
    const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com|youtu\.be)\/(?:watch\?v=)?(?:embed\/)?(?:v\/)?(?:shorts\/)?(?:\S+)/g;
    return text.match(youtubeRegex) || [];
  }
  async extractAudioFiles(source) {
    let text = "";
    if (source === "current") {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile) {
        text = await this.app.vault.read(activeFile);
      }
    } else {
      text = await navigator.clipboard.readText();
    }
    const audioRegex = /(?:^|[\s(])?(?:")?(?:\/|[a-zA-Z]:[\\/])(?:[^"\n\r]*[\\/])*[^"\n\r]*\.(?:mp3|wav|ogg|aac|flac|mp4|mkv|webm|avi|mov|flv)(?:")?(?:\s|$)/gi;
    return text.match(audioRegex) || [];
  }
  showYouTubeModal(links, source) {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText("Select YouTube Link");
    const { contentEl } = modal;
    let selectedIndex = 0;
    const linkList = contentEl.createEl("div", { cls: "fabric-yt-link-list" });
    const updateSelection = () => {
      linkList.querySelectorAll(".fabric-yt-link").forEach((el, index) => {
        el.classList.toggle("is-selected", index === selectedIndex);
      });
    };
    links.forEach((link, index) => {
      const linkEl = linkList.createEl("div", { cls: "fabric-yt-link", text: link });
      linkEl.addEventListener("click", () => {
        selectedIndex = index;
        updateSelection();
      });
    });
    const buttonContainer = contentEl.createEl("div", { cls: "fabric-yt-modal-buttons" });
    const skipButton = buttonContainer.createEl("button", { text: "Skip" });
    skipButton.addClass("skip-button");
    const runYTButton = buttonContainer.createEl("button", { text: "Run" });
    runYTButton.addClass("run-button");
    skipButton.addEventListener("click", () => {
      modal.close();
      this.runFabric(source);
    });
    runYTButton.addEventListener("click", () => {
      modal.close();
      if (links.length > 0) {
        this.runYT(links[selectedIndex]);
      } else {
        new import_obsidian.Notice("No YouTube links found");
      }
    });
    modal.onOpen = () => {
      updateSelection();
      const handleKeyDown = (event) => {
        switch (event.key) {
          case "ArrowUp":
            selectedIndex = (selectedIndex - 1 + links.length) % links.length;
            updateSelection();
            event.preventDefault();
            break;
          case "ArrowDown":
            selectedIndex = (selectedIndex + 1) % links.length;
            updateSelection();
            event.preventDefault();
            break;
          case "Enter":
            modal.close();
            this.runYT(links[selectedIndex]);
            event.preventDefault();
            break;
        }
      };
      document.addEventListener("keydown", handleKeyDown);
      modal.onClose = () => {
        document.removeEventListener("keydown", handleKeyDown);
      };
    };
    modal.open();
  }
  showAudioModal(files, source) {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText("Select Audio File Path");
    const { contentEl } = modal;
    let selectedIndex = 0;
    const fileList = contentEl.createEl("div", { cls: "fabric-ts-link-list" });
    const updateSelection = () => {
      fileList.querySelectorAll(".fabric-ts-link").forEach((el, index) => {
        el.classList.toggle("is-selected", index === selectedIndex);
      });
    };
    files.forEach((file, index) => {
      const linkEl = fileList.createEl("div", { cls: "fabric-ts-link", text: file });
      linkEl.addEventListener("click", () => {
        selectedIndex = index;
        updateSelection();
      });
    });
    const buttonContainer = contentEl.createEl("div", { cls: "fabric-ts-modal-buttons" });
    const skipButton = buttonContainer.createEl("button", { text: "Skip" });
    skipButton.addClass("skip-button");
    const runTSButton = buttonContainer.createEl("button", { text: "Run" });
    runTSButton.addClass("run-button");
    skipButton.addEventListener("click", () => {
      modal.close();
      this.runTS(source);
    });
    runTSButton.addEventListener("click", () => {
      modal.close();
      if (files.length > 0) {
        this.runTS(files[selectedIndex]);
      } else {
        new import_obsidian.Notice("No audio files found");
      }
    });
    modal.onOpen = () => {
      updateSelection();
      const handleKeyDown = (event) => {
        switch (event.key) {
          case "ArrowUp":
            selectedIndex = (selectedIndex - 1 + files.length) % files.length;
            updateSelection();
            event.preventDefault();
            break;
          case "ArrowDown":
            selectedIndex = (selectedIndex + 1) % files.length;
            updateSelection();
            event.preventDefault();
            break;
          case "Enter":
            modal.close();
            this.runTS(files[selectedIndex]);
            event.preventDefault();
            break;
        }
      };
      document.addEventListener("keydown", handleKeyDown);
      modal.onClose = () => {
        document.removeEventListener("keydown", handleKeyDown);
      };
    };
    modal.open();
  }
  async runYT(url) {
    let outputNoteName = this.outputNoteInput.value.trim();
    const pattern = this.selectedPatterns;
    const model = this.getCurrentModel();
    if (!model) {
      new import_obsidian.Notice("Please select a model or set a default model in settings before running.");
      return;
    }
    if (!pattern) {
      new import_obsidian.Notice("Please select a pattern first");
      return;
    }
    this.logoContainer.addClass("loading");
    this.loadingText.setText("");
    this.animateLoadingText(this.getRandomLoadingMessage());
    try {
      const response = await fetch(this.plugin.settings.fabricConnectorApiUrl + "/yt", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-API-Key": this.plugin.settings.fabricConnectorApiKey
        },
        body: JSON.stringify({
          pattern,
          model,
          url,
          stream: true,
          goCompatibility: this.plugin.settings.fabric2
        })
      });
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      const output = data.output;
      const newFile = await this.createOutputNote(output, outputNoteName);
      this.logoContainer.removeClass("loading");
      this.loadingText.setText("");
      new import_obsidian.Notice("YouTube Fabric output generated successfully");
    } catch (error) {
      console.error("Failed to run YouTube Fabric:", error);
      new import_obsidian.Notice("Failed to run YouTube Fabric. Please check your settings and try again.");
    }
  }
  async runTS(path2) {
    let outputNoteName = this.outputNoteInput.value.trim();
    const pattern = this.selectedPatterns;
    const model = this.getCurrentModel();
    if (!model) {
      new import_obsidian.Notice("Please select a model or set a default model in settings before running.");
      return;
    }
    if (!pattern) {
      new import_obsidian.Notice("Please select a pattern first");
      return;
    }
    this.logoContainer.addClass("loading");
    this.loadingText.setText("");
    this.animateLoadingText(this.getRandomLoadingMessage());
    try {
      const response = await fetch(this.plugin.settings.fabricConnectorApiUrl + "/ts", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-API-Key": this.plugin.settings.fabricConnectorApiKey
        },
        body: JSON.stringify({
          pattern,
          model,
          path: path2,
          stream: true,
          goCompatibility: this.plugin.settings.fabric2
        })
      });
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      const output = data.output;
      const newFile = await this.createOutputNote(output, outputNoteName);
      this.logoContainer.removeClass("loading");
      this.loadingText.setText("");
      new import_obsidian.Notice("TS Fabric output generated successfully");
    } catch (error) {
      console.error("Failed to run TS Fabric:", error);
      new import_obsidian.Notice("Failed to run TS Fabric. Please check your settings and try again.");
    }
  }
  async syncCustomPatterns() {
    const customPatternsFolder = this.plugin.settings.customPatternsFolder;
    if (!customPatternsFolder) {
      new import_obsidian.Notice("Custom patterns folder not set. Please set it in the plugin settings.");
      return;
    }
    const folderPath = this.app.vault.getAbstractFileByPath(customPatternsFolder);
    if (!folderPath || !(folderPath instanceof import_obsidian.TFolder)) {
      new import_obsidian.Notice("Custom patterns folder not found in the vault.");
      return;
    }
    for (const file of folderPath.children) {
      if (file instanceof import_obsidian.TFile && file.extension === "md") {
        const content = await this.app.vault.read(file);
        const patternName = file.basename;
        try {
          await this.updatePattern(patternName, content);
          new import_obsidian.Notice(`Pattern "${patternName}" synced successfully.`);
        } catch (error) {
          new import_obsidian.Notice(`Failed to sync pattern "${patternName}": ${error.message}`);
        }
      }
    }
    await this.loadPatterns();
  }
  async updatePattern(name, content) {
    const response = await fetch(this.plugin.settings.fabricConnectorApiUrl + "/update_pattern", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-API-Key": this.plugin.settings.fabricConnectorApiKey
      },
      body: JSON.stringify({
        pattern: name,
        content
      })
    });
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return await response.json();
  }
};
var FabricSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("p", {
      text: "To set up the Fabric Connector:",
      cls: "fabric-settings-instruction"
    });
    containerEl.createEl("ol", { cls: "fabric-settings-list" }, (ol) => {
      ol.createEl("li", { text: "Click the Fabric Connector icon (brain icon) in your system tray" });
      ol.createEl("li", { text: 'For the API URL: Click "Open API Docs" and copy the URL from your browser, removing "/docs" from the end' });
      ol.createEl("li", { text: 'For the API Key: Click "Copy API Key"' });
    });
    new import_obsidian.Setting(containerEl).setName("Fabric Connector API URL").setDesc("Enter the URL for the Fabric Connector API").addDropdown((dropdown) => {
      dropdown.addOption("http://", "http://").addOption("https://", "https://").setValue(this.plugin.settings.fabricConnectorApiUrl.startsWith("https://") ? "https://" : "http://").onChange(async (value) => {
        const domain = this.plugin.settings.fabricConnectorApiUrl.replace(/^https?:\/\//, "");
        this.plugin.settings.fabricConnectorApiUrl = value + domain;
        await this.plugin.saveSettings();
      });
    }).addText((text) => {
      const domain = this.plugin.settings.fabricConnectorApiUrl.replace(/^https?:\/\//, "");
      text.setPlaceholder("Enter domain").setValue(domain).onChange(async (value) => {
        const cleanValue = value.replace(/\//g, "");
        const protocol = this.plugin.settings.fabricConnectorApiUrl.startsWith("https://") ? "https://" : "http://";
        this.plugin.settings.fabricConnectorApiUrl = protocol + cleanValue;
        await this.plugin.saveSettings();
        text.setValue(cleanValue);
      });
    });
    new import_obsidian.Setting(containerEl).setName("Fabric Connector API Key").setDesc("Enter your API key for the Fabric Connector").addText((text) => text.setPlaceholder("Enter API Key").setValue(this.plugin.settings.fabricConnectorApiKey || "").onChange(async (value) => {
      this.plugin.settings.fabricConnectorApiKey = value;
      await this.plugin.saveSettings();
    })).addButton((button) => button.setButtonText("Test API Key").onClick(async () => {
      await this.testFabricConnectorApiKey();
    }));
    new import_obsidian.Setting(containerEl).setName("Tavily API Key").setDesc("Enter your Tavily API key").addText((text) => text.setPlaceholder("Enter API Key").setValue(this.plugin.settings.tavilyApiKey || "").onChange(async (value) => {
      this.plugin.settings.tavilyApiKey = value;
      await this.plugin.saveSettings();
    })).addButton((button) => button.setButtonText("Test API Key").onClick(async () => {
      await this.testTavilyApiKey();
    }));
    new import_obsidian.Setting(containerEl).setName("Output Folder").setDesc("Folder to save output files").addText((text) => text.setPlaceholder("Enter folder path").setValue(this.plugin.settings.outputFolder).onChange(async (value) => {
      this.plugin.settings.outputFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Custom Patterns Folder").setDesc("Folder to store custom patterns").addText((text) => text.setPlaceholder("Enter folder path").setValue(this.plugin.settings.customPatternsFolder).onChange(async (value) => {
      this.plugin.settings.customPatternsFolder = value;
      await this.plugin.saveSettings();
      this.plugin.registerCustomPatternsFolderWatcher();
    }));
    new import_obsidian.Setting(containerEl).setName("Default Model").setDesc("The default model to use when running Fabric").addText((text) => text.setPlaceholder("Enter default model").setValue(this.plugin.settings.defaultModel).onChange(async (value) => {
      this.plugin.settings.defaultModel = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default Post Processing Pattern").setDesc("This pattern will be appended to selected patterns when running Fabric").addText((text) => text.setPlaceholder("Enter pattern name").setValue(this.plugin.settings.defaultPostProcessingPattern).onChange(async (value) => {
      this.plugin.settings.defaultPostProcessingPattern = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Fabric 2.0 Compatibility Mode").setDesc("Enable comptaibility mode for Fabric 2.0").addToggle((toggle) => toggle.setValue(this.plugin.settings.fabric2).onChange(async (value) => {
      this.plugin.settings.fabric2 = value;
      await this.plugin.saveSettings();
      this.plugin.updateLogging();
    }));
    new import_obsidian.Setting(containerEl).setName("Debug Mode").setDesc("Enable debug logging").addToggle((toggle) => toggle.setValue(this.plugin.settings.debug).onChange(async (value) => {
      this.plugin.settings.debug = value;
      await this.plugin.saveSettings();
      this.plugin.updateLogging();
    }));
  }
  async testFabricConnectorApiKey() {
    const fabricConnectorApiUrl = this.plugin.settings.fabricConnectorApiUrl;
    const url = new URL(this.plugin.settings.fabricConnectorApiUrl + "/models");
    url.searchParams.append("goCompatibility", this.plugin.settings.fabric2.toString());
    const apiKey = this.plugin.settings.fabricConnectorApiKey;
    if (!fabricConnectorApiUrl || !apiKey) {
      new import_obsidian.Notice("Please enter both Fabric Connector API URL and API Key");
      return;
    }
    try {
      const response = await fetch(url, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          "X-API-Key": apiKey
        }
      });
      if (response.ok) {
        new import_obsidian.Notice("Fabric Connector API Key is valid");
      } else {
        new import_obsidian.Notice("Invalid Fabric Connector API Key");
      }
    } catch (error) {
      console.error("Error testing Fabric Connector API Key:", error);
      new import_obsidian.Notice("Error testing Fabric Connector API Key. Check console for details.");
    }
  }
  async testTavilyApiKey() {
    const apiKey = this.plugin.settings.tavilyApiKey;
    if (!this.plugin.settings.tavilyApiKey) {
      new import_obsidian.Notice("Please enter a Tavily API Key");
      return;
    }
    try {
      const response = await fetch("https://api.tavily.com/search", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          query: "Test Query",
          max_results: 1,
          api_key: apiKey
        })
      });
      if (response.ok) {
        new import_obsidian.Notice("Tavily API Key is valid");
      } else {
        new import_obsidian.Notice("Invalid Tavily API Key");
      }
    } catch (error) {
      console.error("Error testing Tavily API Key:", error);
      new import_obsidian.Notice("Error testing Tavily API Key. Check console for details.");
    }
  }
};
var CommunityPatternsModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Community Patterns", cls: "community-patterns-title" });
    const buttonContainer = contentEl.createDiv({ cls: "community-patterns-button-container" });
    const updateAllButton = new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Update All").onClick(() => this.updateAllPatterns());
    updateAllButton.buttonEl.className = "fabric-button community-patterns-update-all";
    const refreshPatternsButton = new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Refresh Patterns").onClick(() => this.refreshPatterns());
    refreshPatternsButton.buttonEl.className = "fabric-button community-patterns-refresh";
    this.searchInput = contentEl.createEl("input", {
      type: "text",
      placeholder: "Search patterns...",
      cls: "community-patterns-search"
    });
    this.searchInput.addEventListener("input", () => this.updateResults());
    this.resultsContainer = contentEl.createEl("div", { cls: "community-patterns-results" });
    await this.fetchPatterns();
    this.updateResults();
  }
  async fetchPatterns() {
    try {
      const response = await fetch("https://raw.githubusercontent.com/chasebank87/fabric-patterns/main/patterns.json");
      if (!response.ok) {
        throw new Error("Failed to fetch patterns");
      }
      const data = await response.json();
      this.patterns = Object.keys(data.patterns).map((key) => ({
        name: key,
        ...data.patterns[key]
      }));
    } catch (error) {
      console.error("Error fetching patterns:", error);
      new import_obsidian.Notice("Failed to fetch patterns");
    }
  }
  async isPatternInstalled(patternName) {
    const file = `${this.plugin.settings.customPatternsFolder}/${patternName}.md`;
    return await this.app.vault.adapter.exists(file);
  }
  async doesPatternNeedUpdate(patternName, pattern_repo) {
    const installedPath = `${this.plugin.settings.customPatternsFolder}/${patternName}.md`;
    const repoPath = "https://raw.githubusercontent.com/" + pattern_repo + "/main/patterns/" + patternName + ".md";
    const installedContent = await this.app.vault.adapter.read(installedPath);
    const response = await fetch(repoPath);
    if (!response.ok) {
      throw new Error("Failed to fetch pattern content");
    }
    const repoContent = await response.text();
    return installedContent !== repoContent;
  }
  async updateResults() {
    const searchTerm = this.searchInput.value.toLowerCase();
    const filteredPatterns = this.patterns.filter(
      (pattern) => pattern.name.toLowerCase().includes(searchTerm) || pattern.description.toLowerCase().includes(searchTerm) || pattern.author.toLowerCase().includes(searchTerm)
    );
    this.resultsContainer.empty();
    for (const pattern of filteredPatterns) {
      try {
        let currentPatternUrl = "https://raw.githubusercontent.com/" + pattern.pattern_repo + "/main/patterns/" + pattern.name + ".md";
        const response = await fetch(currentPatternUrl);
        if (!response.ok) {
          console.warn(`Pattern ${pattern.name} has an invalid URL: ${currentPatternUrl}`);
          continue;
        }
        const patternEl = this.resultsContainer.createEl("div", { cls: "community-pattern-item" });
        const patternInfo = patternEl.createEl("div", { cls: "community-pattern-info" });
        patternInfo.createEl("div", { text: pattern.name, cls: "community-pattern-title" });
        patternInfo.createEl("div", { text: pattern.description, cls: "community-pattern-description" });
        patternInfo.createEl("em", { text: `by ${pattern.author}`, cls: "community-fabric-author" });
        patternInfo.createEl("small", { text: `For models: ${pattern.for_models}`, cls: "community-fabric-models" });
        const isInstalled = await this.isPatternInstalled(pattern.name);
        const needsUpdate = isInstalled && await this.doesPatternNeedUpdate(pattern.name, pattern.pattern_repo);
        const buttonContainer = patternEl.createEl("div", { cls: "community-pattern-buttons" });
        if (!isInstalled) {
          const downloadBtn = new import_obsidian.ButtonComponent(buttonContainer).setButtonText("").onClick(() => this.downloadPattern(pattern.name, pattern.pattern_repo));
          downloadBtn.buttonEl.className = "community-pattern-download";
          (0, import_obsidian.setIcon)(downloadBtn.buttonEl, "download");
        } else {
          if (needsUpdate) {
            const updateBtn = new import_obsidian.ButtonComponent(buttonContainer).setButtonText("").onClick(() => this.updatePattern(pattern.name, pattern.pattern_repo));
            updateBtn.buttonEl.className = "community-pattern-update";
            (0, import_obsidian.setIcon)(updateBtn.buttonEl, "refresh-cw");
          }
          const uninstallBtn = new import_obsidian.ButtonComponent(buttonContainer).setButtonText("").onClick(() => this.uninstallPattern(pattern.name));
          uninstallBtn.buttonEl.className = "community-pattern-uninstall";
          (0, import_obsidian.setIcon)(uninstallBtn.buttonEl, "trash");
        }
      } catch (error) {
        console.error(`Error processing pattern ${pattern.name}:`, error);
      }
    }
  }
  async downloadPattern(patternName, pattern_repo) {
    try {
      let patternUrl = "https://raw.githubusercontent.com/" + pattern_repo + "/main/patterns/" + patternName + ".md";
      console.log(patternUrl);
      const response = await fetch(patternUrl);
      if (!response.ok) {
        throw new Error("Failed to download pattern");
      }
      const content = await response.text();
      const file = `${this.plugin.settings.customPatternsFolder}/${patternName}.md`;
      await this.app.vault.create(file, content);
      new import_obsidian.Notice(`Pattern ${patternName} downloaded successfully`);
      this.updateResults();
    } catch (error) {
      console.error("Error downloading pattern:", error);
      new import_obsidian.Notice("Failed to download pattern");
    }
  }
  async updatePattern(patternName, pattern_repo) {
    try {
      let patternUrl = "https://raw.githubusercontent.com/" + pattern_repo + "/main/patterns/" + patternName + ".md";
      const response = await fetch(patternUrl);
      if (!response.ok) {
        throw new Error("Failed to update pattern");
      }
      const content = await response.text();
      const file = `${this.plugin.settings.customPatternsFolder}/${patternName}.md`;
      await this.app.vault.adapter.write(file, content);
      new import_obsidian.Notice(`Pattern ${patternName} updated successfully`);
      this.updateResults();
    } catch (error) {
      console.error("Error updating pattern:", error);
      new import_obsidian.Notice("Failed to update pattern");
    }
  }
  async refreshPatterns() {
    await this.fetchPatterns();
    this.updateResults();
    new import_obsidian.Notice("Patterns list refreshed");
  }
  async uninstallPattern(patternName) {
    try {
      const file = `${this.plugin.settings.customPatternsFolder}/${patternName}.md`;
      await this.app.vault.adapter.remove(file);
      new import_obsidian.Notice(`Pattern ${patternName} uninstalled successfully`);
      this.updateResults();
    } catch (error) {
      console.error("Error uninstalling pattern:", error);
      new import_obsidian.Notice("Failed to uninstall pattern");
    }
  }
  async updateAllPatterns() {
    let updatedCount = 0;
    for (const pattern of this.patterns) {
      const isInstalled = await this.isPatternInstalled(pattern.name);
      const needsUpdate = isInstalled && await this.doesPatternNeedUpdate(pattern.name, pattern.pattern_repo);
      if (needsUpdate) {
        await this.updatePattern(pattern.name, pattern.pattern_repo);
        updatedCount++;
      }
    }
    new import_obsidian.Notice(`Updated ${updatedCount} patterns`);
    this.updateResults();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
